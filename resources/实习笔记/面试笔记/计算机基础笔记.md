# 计算机网络

## OSI七层模型

让每一层专注于做一件事情，各层相互独立，用接口相连。高内聚低耦合，更灵活。

| 七层               | 作用                                                         | TCP/IP                                                       |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 物理层             | 比特流，**透明**比特传输，屏蔽掉具体传输介质和物理设备的差异 | 物理层+数据链路层=**网络接口层**<br />MAC，CSMA/CD<br />多路访问（信道复用）、差错检测 |
| 数据链路层         | 帧，帧编码和误差纠正                                         |                                                              |
| 网络层/网际层/IP层 | 数据包，路由和寻址                                           | **网络层**，分组交换，不同主机的通信。负责路由和寻址。<br />IP、ICMP、ARP、NAT |
| 传输层             | 数据段，为两台主机的通信提供数据传输                         | **传输层**，进程通信的通用数据传输，多种应用可以使用同一个传输层服务。<br />TCP协议：面向连接，可靠；UDP：无连接，尽最大努力，不可靠 |
| 会话层             |                                                              | 这三层是**应用层**，<br />定义两个<font color='red'>应用程序</font>**信息交换**格式，提供信息交换服务<br />定义了网络通信规则，HTTP，DNS，SMTP，POP3（邮件接收协议），FTP，SSH，Telnet（远程登陆协议），RTP（实时传输协议） |
| 表示层             |                                                              |                                                              |
| 应用层             | 为计算机用户提供服务                                         |                                                              |

![image-20230420181926775](https://gitee.com/ziye1005/test-typora/raw/master/imgTypora/image-20230420181926775.png)



## 应用层

### 应用层协议

| 应用层协议                       | 概述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| HTTP超文本传输协议               | Web 浏览器与服务器的通信；<br />基于TCP协议，建立三次握手；Keep-Alive，可以连接复用；<br />**HTTP ”无状态”，通过 Session记录客户端用户的状态。** |
| SMTP简单邮件传输（**发送**）协议 | 基于TCP协议，**只负责发送**<br />发送过程：通过SMTP将邮件交给163服务器；163服务器识别目的邮箱类型为QQ，通过SMTP转交给qq服务器；qq服务器通知qq用户接收邮件，采用POP3或者IMAP协议取出。<br />判断邮箱是否存在：  查找邮箱域名对应的 **SMTP 服务器地址**；尝试与服务器建立连接；连接成功后尝试向目的邮箱发送邮件；根据返回结果判定邮箱地址的真实性 |
| POP3/IMAP（互联网消息访问协议）  | 负责邮件接收的协议<br />IMAP比POP3的可选功能更多             |
| FTP                              | 基于TCP，可靠的文件传输<br />主机间使用了两条 TCP 连接（其它客户服务器应用程序只有一条）：<br />控制连接：用于传送**控制信息**（命令和响应） 数据连接：用于**数据**传送。<br />**命令和数据分开传送**的思想大大提高了 FTP 的效率 |
| Telnet                           | 基于TCP，  远程终端登录。所有数据（用户名密码）明文传输，不安全 |
| SSH（Secure shell）              | 基于TCP，安全协议，防止信息泄露                              |
|                                  |                                                              |
| DHCP                             | 动态主机配置协议，动态配置 IP 地址                           |
| DNS                              | 域名系统，互联网的“**电话簿**“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。将人类能记住的域名转换为机器可读的 IP 地址 |

### HTTP协议

| 打开网页过程                      | 所用协议              |                                                              |
| --------------------------------- | --------------------- | ------------------------------------------------------------ |
| 1.DNS解析：浏览器查找域名的IP地址 | DNS：获取域名对应的IP |                                                              |
| 2.TCP连接                         | TCP，IP，OSPF，ARP    | TCP：传输层与服务器建立TCP连接<br />IP：网络层使用IP协议发送数据<br />OSPF：IP数据报在路由之间使用OSPF选择路由<br />ARP：路由器与服务器通信，使用ARP协议<br /> |
| 3.发送HTTP请求                    | HTTP                  | HTTP：TCP建立连接完成后，使用HTTP访问网页                    |
| 4.服务器处理请求并返回 HTTP 报文  |                       |                                                              |
| 5.浏览器解析渲染页面              |                       |                                                              |

状态码：

|      | 类别                      | 原因                                                         |
| ---- | ------------------------- | ------------------------------------------------------------ |
| 1XX  | Informational信息类状态码 | 正在处理请求；一般碰不到                                     |
| 2XX  | success成功               | 200OK（请求被成功处理）<br />201Created（成功处理 && 在server创建一个新的资源）<br />202Accepted（Server成功接到请求，尚未处理）<br />204No content（成功处理 && 没有返回内容） |
| 3XX  | rediretion重定向          | 需要附加操作以完成请求                                       |
| 4XX  | client错误码              | 400 Bad Request ：HTTP请求错误（请求参数不合法、请求方法错误）<br />401 Unauthorized ： 未认证<br />403 Forbidden（非法请求）<br />404 Not found（请求资源未在Server找到） |
| 5XX  | server错误码              | 500：服务器出问题了<br />502：网关未响应                     |



|        | HTTP                                                         | HTTPS                                                        |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 端口   | 80                                                           | 443                                                          |
| 底层   | 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）           | TCP                                                          |
| 优点   | 展性强、速度快、跨平台支持性好                               | 保密性好、信任度高                                           |
| 缺点   | 无状态，**不维护任何有关客户端的历史请求**                   |                                                              |
| 安全性 | 不安全，所有传输的内容都是明文（数据透明），客户端和服务器端都无法验证对方的身份 | 所有传输的内容都经过加密，SSL/TLS协议采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。 |

无状态： HTTP 协议自身不对请求和响应之间的通信状态进行保存，通过Session记录用户状态。在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

**Cookie 被禁用怎么办?**最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面

|            | HTTP1.0 | HTTP1.1                                |
| ---------- | ------- | -------------------------------------- |
| 连接方式   | 短连接  | 长连接                                 |
| 状态响应码 |         | 1.1中新加入了大量的状态码，206 409 410 |
| Host头处理 |         | HTTP/1.1在请求头中加入了`Host`字段     |



## 传输层

### 传输层协议

| 传输层协议       | TCP                                                          | UDP                        |
| ---------------- | ------------------------------------------------------------ | -------------------------- |
| 连接，可靠       | 面向连接，可靠。                                             | 无连接，尽最大努力，不可靠 |
| 是否有状态       | 有状态，会去记录自己发送消息的状态比如消息是否发送了、是否被接收了。维护复杂的链接状态表 | 无状态，发完就不管         |
| 效率             | 有确认连接、重传等，低很多                                   |                            |
| 传输形式         | 面向**字节流**                                               | 面向**报文**               |
| 首部开销         | 20B （不含可选字段optional）～ 60 B                          | 12B假头部+8B真头部         |
| 适合场景         | 准确性要求高的，文件传输、收发邮件、远程登陆                 | 实时性要求高的，语音视频   |
| 是否提供广播多播 | 点对点                                                       | 有广播、多播               |

### TCP三次握手

<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解" style="zoom: 80%;" />

**一次握手**:客户端发送带有 SYN（SEQ=x随机产生的包） 标志的数据包 -> 服务端，表示想要**连机**。然后客户端进入 **SYN_SEND** 状态，等待服务器的确认；
**二次握手**:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –> 客户端,然后服务端进入 **SYN_RECV** 状态
**三次握手**:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –> 服务端，然后客户端和服务器端都进入**ESTABLISHED** 状态，完成TCP三次握手。

**当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！**

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的，缺一不可。

### TCP四次挥手

<img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解" style="zoom:80%;" />

断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：

1. **第一次挥手** ：客户端发送一个 FIN（SEQ=X） 标志的数据包->服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 **FIN-WAIT-1** 状态。
2. **第二次挥手** ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包->客户端 。然后，此时服务端进入**CLOSE-WAIT**状态，客户端进入**FIN-WAIT-2**状态。
3. **第三次挥手** ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包->客户端请求关闭连接，然后，服务端进入**LAST-ACK**状态。
4. **第四次挥手** ：客户端发送 ACK (SEQ=y+1)标志的数据包->服务端并且进入**TIME-WAIT**状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 **2MSL** 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。

**只要四次挥手没有结束，客户端和服务端就可以继续传输数据！**

TCP是**全双工通信**，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。

为什么不能将Server的ACK和FIN合为一个：因为Server收到ACK后，可能还有数据需要传输，传完才能发送FIN。

如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？客户端没有收到 ACK 确认，会重新发送 FIN 请求

2* MSL：2倍的报文段最长寿命。考虑到Client的ACK可能丢失。如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。

### 可靠性保证

| 可靠性                     | 概述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 基于数据块传输             | 应用数据被分割成 TCP 认为最适合发送的数据块                  |
| 对失序数据重新排序以及去重 | 给每个包一个序列号，防止丢包以及去重                         |
| 校验和                     |                                                              |
| 超时重传                   | 启动定时器，保证接收ACK，否则重传                            |
| 流量控制                   | TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。<br />当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。<br />TCP 利用滑动窗口实现流量控制。 |
| 拥塞控制                   | 当网络拥塞时，减少数据的发送                                 |

### 流量控制

流量控制：端到端的控制，作用于sender，receiver控制sender发送速率，保证receiver来得及接收，避免分组丢失。

由滑动窗口协议（**连续ARQ协议，Automatic repeat request，自动重传请求**）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。

死锁：当发送者收到了一个零窗口的应答，发送者便停止发送，等待接收者的下一个应答。但如果接收者的应答都丢掉了，就会出现sender等待发送，receiver等待接收的死锁。

死锁解决：每当发送者收到一个零窗口的应答后，TCP启动**持续计时器**。时间一到主动询问receiver窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，重置发送窗口开始发送，避免死锁产生。

因为全双工通信，sender和receiver各自维护一个发送窗口和接收窗口，通信双方的发送窗口和接收窗口的要求相同。
发送滑动窗口= 已发送未确认+即将发送（接收方准备好接收的，但sender还没发），已发送已确认 可以滑走，未准备发送不能滑到。
接收滑动窗口= 等待接收，已确认接收可以滑走，不能接收不能滑到。

### ARQ协议

OSI 模型中**数据链路层和传输层的错误纠正协议之一**。它通过使用确认和超时这两个机制，实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息ACK，它通常会重新发送，直到收到确认或者重试超过一定的次数。
包括停止等待ARQ和连续ARQ。

1.停止等待ARQ：
每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

**1) 无差错情况:**发送方每发完一个分组就停止发送，等待对方的ACK，然后发送方再次发送。
**2) 出现差错情况（超时重传）:**如果超过超时计时器的时间，仍然没有收到ACK，就认为刚才发送过的分组丢失了，进行重传。在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。
**3) 确认丢失和确认迟到：**
确认丢失 ：receiver收到数据，但ACK丢了，因此收到重传的重复分组，则：丢弃该分组，发送ACK；
确认迟到：receiver收到数据，但ACK到晚了，超过了超时计时器的时间。因此receiver收到重复数据（丢弃重复分组，发送ACK），sender收到重复ACK（丢弃重复ACK）。

2.连续ARQ：
发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用**累计确认**，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

### 拥塞控制

拥塞控制：全局性的过程，涉及到所有的主机、路由器。作用于网络。防止过多的数据注入到网络中，导致网络过载。

（ 1 ）发生拥塞：慢开始、拥塞避免（ 2 ）没有发生拥塞：快重传、快恢复。

![TCP的拥塞控制](https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-congestion-control.png)

TCP连接初始化，将拥塞窗口设置为1 （先试探着增长），初始阈值为16
慢开始：cwnd按指数增长，不断翻倍；
拥塞避免：达到阈值之后，cwnd线性增长，每次+1。如果发生超时，则将cwnd重新设置为1，阈值设置为超时窗口的一半24/ 2= 12，重新慢开始。
快重传、快恢复FRR：一旦接收到不按顺序的数据包，立刻返回一个3-ACK，sender立即重传丢失的数据。阈值和窗口设置为当前窗口的一半16/2 = 8，**开始拥塞避免**（认为收到3ACK说明没有阻塞，不从慢开始）

超时则阈值减半慢开始，FRR丢包则阈值减半拥塞避免。

## 网络层

| 网络层协议          | 概述                                                         |
| ------------------- | ------------------------------------------------------------ |
| IP网际协议          | 寻址规约、定义数据包的格式。IPv4 32位； IPv6 128位           |
| ARP地址解析协议     | 网络层地址（逻辑地址，IP地址）:arrow_right:链路层地址（物理地址，MAC地址） |
| NAT网络地址转换协议 | 内网地址（LAN）:arrow_right:外网地址（WLAN）                 |
| ICMP协议            | ping，验证网络是否畅通                                       |

### ARP协议

**偏底层的、非常重要的、又非常简单的**通信协议。解决的是网络层地址（IP逻辑地址）和链路层地址（MAC物理地址）之间的转换问题。

MAC地址：长度48位6字节，地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。
广播地址（特殊地址）：FF-FF-FF-FF-FF-FF（全 1 地址）
ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。

**同一局域网内的ARP**：主机A根据IP地址向B发送IP数据报：
1.检索自己的**ARP表**，如果存在，则取出MAC地址构造数据链路帧；
2.如果不存在，则构建一个**ARP查询分组**（发送和接收的 IP 地址、发送的MAC 地址、接收的MAC地址：初始为全1广播地址），在自己的局域网中**广播查询分组**；
3.每个设备都检查是不是自己的IP，如果是，返回一个ARP响应分组（同样包含发送和接收的IP、MAC地址），先在自己的ARP表中增加A的IP-MAC记录，然后**单播响应分组**给A；
4.A接收到该响应分组，加入自己的ARP表，构造数据链路帧。

不同局域网的ARP：
主机 A 查询 ARP 表，期望寻找到目标路由器的**本子网接口的 MAC 地址**，将链路层帧单播给接口，接口转发给主机B所在的子网的接口。由B的接口来进行广播查询和单播响应。

## TCP/IP网络攻击

| 攻击技术    | 定义                                                         | 预防                                                         |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| IP欺骗      | 伪造合法主机的IP地址，暂停服务器对合法主机的服务             | 在网络边缘实施**入口过滤**，阻止伪造包渗入网络               |
| DDos攻击    | 分布的、协同的大规模攻击方式： ICMP Flood、UDP Flood、NTP Flood、SYN Flood、CC 攻击、DNS Query Flood | 黑名单，高防服务器                                           |
| SYN flood   | **利用三次握手协议**，找僵尸机发送**变源**IP地址，耗尽可用服务器资源，致使服务器无法传输合法流量。 | 判断哪些连接请求来自于真实源，屏蔽非真实源请求               |
| UDP flood   | 接收UDP报文时，利用**ICMP**（ping）数据包进行资源检查。将大量UDP发给server，耗尽资源。 | 限制了 ICMP 报文的响应速率，以中断需要 ICMP 响应的 DDoS 攻击 |
| HTTP flood  | 利用 HTTP 请求使目标服务器不堪重负。有HTTP Get（请求图像）和Post（提交表单） | 对设备进行质询，验证真人                                     |
| TCP重置攻击 | 攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断 | 特殊的 IP 扩展协议（例如 `IPSec`）可以验证身份               |
| 中间人攻击  | 攻击者与通讯的两端分别创建独立的联系                         | 数字证书和签名。对称加密（DES AES）非对称加密（RSA）散列加密（SH512 MD5） |

# 操作系统

## 操作系统基础

操作系统是管理计算机软硬件资源的**软件程序**，为软件屏蔽了底层硬件的复杂性。操作系统内核是OS的核心部分。
内核 VS CPU：内核属于软件，负责系统管理内存管理；CPU属于硬件，提供运算处理指令。

![Kernel_Layout](https://oss.javaguide.cn/2020-8/Kernel_Layout.png)

OS功能：
进程和线程的管理：创建、撤销、阻塞、唤醒，通信
存储管理：内存 & 外存的分配与管理
文件管理：文件的新建、删除、读写改
设备管理：IO设备的请求和释放
网络管理：网络的连接、通信、安全
安全管理：身份认证、访问控制、文件加解密

常见的OS：
Windows：界面交互性好，软件生态好
Unix：最早的多任务多用户OS，Linux很多参考了Unix，但现在逐渐退出市场。
Linux：免费试用、开源的Unix，速度快，轻量化
Mac OS：编程体验与Linux相当，但界面和软件生态更好。

用户态 VS 内核态：
**用户态(User Mode)** : 权限低，用户态进程可以直接读取用户程序数据。对于读写磁盘、网络通信高权限的**特权指令**，需要向OS发起系统调用请求，进入内核态。
**内核态(Kernel Mode)** ：权限高，内核态进程几乎可以访问计算机的任何资源（系统的内存空间、设备、驱动程序），可以执行**特权指令**（内存分配、设置时钟、IO处理）。当操作系统接收到进程的**系统调用请求**时，就会从用户态**切换**到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。
同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。如果只有一个态，特权指令由所有进程自己处理很不安全，效率也低。

![用户态和内核态](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/usermode-and-kernelmode.png)

切换方式：系统调用，中断、异常
1.系统调用和中断：我们运行的程序基本都是运行在用户态，为了调用内核级别的子功能（网络通信、磁盘IO、内存分配、设备调用），用户态**主动**要求切换到内核态，请求OS代为完成。系统调用的核心是**中断**。
步骤：用户态程序发起系统调用，中断执行（trap）；当前CPU会离开用户态进程，跳转到终端处理程序，内核态程序开始执行，处理系统调用；内核处理完之后，主动触发trap，再次中断，切换回用户态。

2.异常：用户态下，发生了异常，会触发切换到内核态处理异常（缺页异常）

![系统调用的过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/system-call-procedure.png)

## 进程与线程

PCB：进程控制块，OS创建进程时，会分配一个唯一的进程ID，和一个对应的PCB。每个进程都有一个独立的PCB。

| PCB内容      | 描述                                              |
| ------------ | ------------------------------------------------- |
| 进程描述信息 | 进程名称、标识符                                  |
| 调度信息     | 状态、阻塞原因、优先级                            |
| 资源需求     | CPU时间、内存空间、IO设备                         |
| 文件信息     | 文件描述符、文件类型                              |
| 处理机状态   | 通用寄存器、指令计数器、程序状态字PSW、用户栈指针 |

进程通信方式：

| 通信方式              | 描述                                                         |
| --------------------- | ------------------------------------------------------------ |
| 管道/匿名管道(Pipes)  | 有亲缘关系的父子进程、兄弟进程之间的通信，没有名字，只存在于内存中的文件 |
| 有名管道(Named Pipes) | 遵循FIFO，存在于实际的磁盘介质或者文件系统，可以实现本机任意两个进程通信（不需要有关系） |
| 信号(Signal)          | 复杂的通信方式，用于通知接收进程某个事件已经发生             |
| **消息队列**          | FIFO，存在于内核中，消息的链表，消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点 |
| 信号量Semaphores      | 实现多进程访问共享数据时的计数器，实现同步                   |
| 套接字sockets         | 支持 TCP/IP 的网络通信的基本操作单元，Client和Server之间双向网络通信的约定 |

### 进程调度算法:star:

| 进程调度算法                     | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| FCFS先到先服务                   |                                                              |
| SJF短作业优先                    |                                                              |
| 时间片轮转， RR(Round robin)调度 | 最古老，最简单，最公平且使用最广的算法                       |
| 多级反馈队列调度                 | 兼顾高优先级 && 短作业，是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采用 |
| 优先级调度                       | 高优先级的优先，同优先级的FCFS                               |

父进程和子进程：
子进程通常是父进程通过 fork()系统调用创建的，二者的运行相互独立，各自拥有自己的 PCB，一个结束了另一个依然可以运行。但只有父进程可以使用子进程，子进程即使exit()系统调用结束，必须要父进程调用wait()或 waitpid()系统调用才能释放子进程的PCB。因此会出现僵尸进程（父在子不在）和孤儿进程（子在父不在）。

僵尸进程和孤儿进程：
**僵尸进程** ：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。
**孤儿进程** ：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），**由 init 进程来回收孤儿进程的资源**。

查看僵尸进程： linux下：Top 命令查找，zombie 值表示僵尸进程的数量，为 0 则代表没有僵尸进程

## 内存管理

**内存的分配与回收** ：对进程所需的内存进行分配和释放，**malloc **：申请内存，**free **：释放内存。
**地址转换** ：将程序中的虚拟地址转换成内存中的物理地址。
**内存扩充** ：当系统没有足够的内存时，利用**虚拟内存技术**或**自动覆盖技术**，从逻辑上扩充内存。
**内存优化** ：通过调整内存分配策略和回收算法来优化内存使用效率。
**内存安全** ：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。

### 内存碎片

内部碎片：由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就产生了内部碎片，通常内部碎片难以完全避免。
外部碎片：未分配的连续内存区域太小，不能满足任何线程

解决方法：段页式，每一段由多个固定大小的页组成，通过页表机制，使得段内的页不必连续，减少了外部碎片；但可能存在少量内部碎片，但只要页足够小，内存碎片就更小。

### 内存管理

连续内存管理：**块式管理** 是早期计算机操作系统的一种连续内存管理方式，存在严重的内存碎片问题。

非连续内存管理存在下面 3 种方式：

- **段式管理** ：以段(一段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为**大小不等的段**，段是有实际意义的，**每个段定义了一组逻辑信息**，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。
- **页式管理** ：把物理内存分为**连续等长的物理页**，应用程序的虚拟地址空间划也被分为连续等长的虚拟页，现代操作系统**广泛使用**的一种内存管理方式。
- **段页式管理** ：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。



### 虚拟内存

本质上它只是逻辑存在，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁，简化内存管理。

![虚拟内存作为进程访问主存的桥梁](https://oss.javaguide.cn/xingqiu/virtual-memory.png)

**隔离进程** ：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。
**提升物理内存利用率** ：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。
**简化内存管理** ：进程都有一个一致且私有的虚拟地址空间，程序员**不用和真正的物理内存打交道**，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。
**提高内存使用安全性** ：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。
**提供更大的可使用内存空间** ： 可以让程序拥有**超过系统物理内存大小**的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）**保存到磁盘文件**（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。

### 虚拟地址和物理地址

地址翻译、地址转换：OS通过MMU（内存管理单元）将虚拟地址转为物理地址，但编程开发使用的都是虚拟地址。


![地址翻译过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/physical-virtual-address-translation.png)

虚拟地址和物理地址的映射机制：分段、分页、段页。分页最常用。

#### 分段机制：外部碎片

以段(一段**连续的物理内存**)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为**大小不等的段**，段是有实际意义的，**每个段定义了一个进程的逻辑信息**，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。

通过**段表**映射虚拟地址和物理地址，虚拟地址包括：段号（标记属于虚拟空间的哪一段）和段内偏移量（相对于该段起始地址的偏移量）。段表包括：段号，起始物理地址，段长（检查虚拟地址是否超出合法范围），段类型（代码段，数据段）

具体的地址翻译过程如下：
MMU 首先解析得到虚拟地址中的段号；
通过段号去该应用程序的段表中取出对应的段的起始物理地址（找到对应的段表项）；
从段信息中取出该段的起始地址（物理地址）加上虚拟地址中的段内偏移量得到最终的物理地址，去内存中取数据。

![分段机制下的地址翻译过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-virtual-address-composition.png)

效果：段与段之间会有**外部碎片**

![分段机制导致外部内存碎片](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/segment-external-memory-fragmentation.png)

#### 分页机制：内部碎片

把物理内存分为**连续等长的物理页**，应用程序的虚拟地址空间划也被分为连续等长的虚拟页，现代操作系统**广泛使用**的一种内存管理方式。页是没有实际意义的。

通过**页表**映射虚拟地址和物理地址，**每个应用程序**都会有一个对应的页表。页表包括：页号，页内偏移量，访问标志（标识该页面有没有被访问过）、页类型（代码段、数据段等）

具体的地址翻译过程如下：
MMU 首先解析得到虚拟地址中的虚拟页号；
通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）；
用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。

![分页机制下的地址翻译过程](https://oss.javaguide.cn/github/javaguide/cs-basics/operating-system/paging-virtual-address-composition.png)

<font color='red'>单级页表和多级页表</font>（32 位系统：二级页表，64 位系统：四级页表）：
单级页表空间计算：虚拟地址范围4G=2^32，一页大小4KB=2 ^ 12，一个页表项占4B。页表项有4G/4K=2 ^ 20，需要2 ^ 12KB空间，但实际上根本不会用到全部虚拟地址，只用到里面的几页。
多级页表空间计算：分为两级，一级页表有1张，4KB/4K = 2 ^ 10个页表项，二级页表2 ^ 10个，乘起来也是2 ^20个页表项。但一般根本用不到这么多空间，假设只用到两张二级页表，需要4KB + 4KB * 2 = 12KB.
属于**时间换空间的典型场景**，利用**增加页表查询的次数减少页表占用的空间**

<font color='red'>TLB</font>（快表），一块高速缓存，存储key（虚拟页号）value（物理页号）对的哈希表。
1.用虚拟地址中的虚拟页号作为 key 去 TLB 中查询；
2.如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。
3.如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。
4.当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

由于页表也在主存中，因此在没有 TLB 之前，每次读写内存数据时 CPU 要访问两次主存。有了 TLB 之后，对于存在于 TLB 中的页表数据只需要访问一次主存即可。
TLB 的设计思想非常简单，但命中率往往非常高，效果很好。这就是因为被频繁访问的页就是其中的很小一部分（**空间局限性**）。

<font color='red'>页缺失：</font>
硬性页缺失（Hard Page Fault） ：**物理内存中没有对应的物理页**。于是，Page Fault Hander 会指示 CPU 从已经打开的**磁盘文件**中读取相应的内容到物理内存，而后交由 **MMU 建立**相应的虚拟页和物理页的映射关系。
软性页缺失（Soft Page Fault）：物理内存中有对应的物理页，但虚拟页还未和物理页建立**映射**。于是，Page Fault Hander 会指示 MMU 建立相应的虚拟页和物理页的映射关系。

#### <font color='red'>页面置换算法：</font>（硬性页缺失）:star:

1.最佳页面置换算法（OPT，Optimal） ：优先选择淘汰的页面是**<font color='red'>以后</font>**永不使用的，或者是在**最长时间内不再被访问**的页面，**无法实现**，理论最优，可以作为衡量其他置换算法优劣的标准。
2.先进先出页面置换算法FIFO : 最简单，总是淘汰最先进入内存的页面。
3.最近最久未使用页面置换算法（<font color='red'>LRU</font> ，Least Recently Used） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，选择T最大的淘汰，即**之前最长时间不使用**的淘汰。
4.最少使用页面置换算法（LFU，Least Frequently Used） : 类似 LRU ，**之前最少次数使用**的淘汰。
4.时钟页面置换算法（Clock） ：可以认为是一种最近未使用算法，即逐出的页面都是最近没有使用的那个。

LRU使用的最多，改进款有Adaptive LRU（InnoDB 缓冲池，MySQL 数据库中用于管理缓存页面的机制）

#### 区别与联系

|              | 分段                                                         | 分页                                     |
| ------------ | ------------------------------------------------------------ | ---------------------------------------- |
| 共同点       | 非连续内存管理，地址映射                                     |                                          |
| 区别——单位   | 以大小不等的段为单位，取决于进程，逻辑单位                   | 以大小固定的页为单位，取决于OS，物理单位 |
| 碎片         | 外部碎片                                                     | 少量内部碎片                             |
| 地址映射手段 | 段表                                                         | 多级页表                                 |
| 对程序的要求 | 需要程序员将程序分为多个段，并且显式地使用段寄存器来访问不同的段 | 没有要求，页没有逻辑意义                 |



#### 局部性原理

数据和指令的访问存在一定的空间和时间上的局部性。时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。

局部性原理是计算机体系结构设计的重要原则之一，也是许多**优化算法**的基础。在分页机制中，利用时间局部性和空间局部性，采用**缓存和预取**技术，可以提高页面的命中率，从而提高内存访问效率。

## 文件系统

1.功能
管理和组织计算机存储设备上的文件和目录。
存储管理：将文件存储到物理介质上，管理空间分配
文件管理：文件的创建、删除、移动等
目录管理：目录的创建、删除、移动等
文件访问控制：管理不同用户或进程对文件的访问权限

2.硬链接和软链接：

每个文件和目录有唯一的索引节点号（inode），用来标识该文件或目录。
每个文件系统都有自己的独立 inode 表，且每个 inode 表只维护该文件系统内的 inode。如果在不同的文件系统之间创建硬链接，可能会导致 inode 节点号冲突的问题，即目标文件的 inode 节点号已经在该文件系统中被使用。

| 硬链接                                                       | 软链接                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 硬链接通过inode建立链接，硬链接和源文件的inode相同，互为硬链接，源头是同一份文件 | 软链接不是指向inode，而是指向文件路径。                      |
| 只有删除了源文件和硬链接文件，该文件才能被真正删除。因此用来防止重要文件被误删 | 源文件删除后，硬链接依然存在，但是指向的是一个无效的文件路径。 |
| 不能对目录以及不存在的文件创建硬链接，并且，硬链接也**不能跨越文件系统** | 可以对目录或者不存在的文件创建软链接，并且，软链接**可以**跨越文件系统。 |
| In命令创建硬链接                                             | `ln -s` 命令用于创建软链接                                   |

3.提高文件系统性能的方式

优化硬件：使用高速硬件设备（如 SSD、NVMe）替代传统的机械硬盘。
选择合适的文件系统选型 ：不同的文件系统（NTFS，ext4）具有不同的特性
运用缓存 ：访问磁盘的效率比较低，可以运用缓存减少磁盘IO。但需要注意缓存命中率。
避免磁盘过度使用 ：注意磁盘的使用率，避免将磁盘用满。
对磁盘进行合理的分区 ：合理的磁盘分区方案，能够使文件系统在不同的区域存储文件，从而减少文件碎片，提高文件读写性能。

### 磁盘调度算法:star:

是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。

| 磁盘调度算法               | 描述                                                         | 寻道时间                                     | 饥饿 |
| -------------------------- | ------------------------------------------------------------ | -------------------------------------------- | ---- |
| FCFS                       | 不存在算法开销。没有考虑磁头移动的路径和方向。               | 平均寻道时间较长                             | 会   |
| SSTF最短寻道时间优先       | 优先选择距离当前磁头位置最近的请求进行服务                   | 最小化磁头寻道时间                           | 会   |
| SCAN扫描（电梯算法）       | 磁头沿着一个方向（:arrow_down:）扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界改变方向，然后。:arrow_up: | 如果刚扫描完就来了新的，这个新的需要等2*时间 | 不会 |
| CSCAN循环扫描              | 磁头沿着一个方向（:arrow_down:）扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界改变方向，然后回到最上面，继续:arrow_down: |                                              | 不会 |
| LOOK（边扫描边观察）       | SCAN改进，如果到了一个位置，该方向没有请求了，立刻掉头:arrow_up: |                                              |      |
| 均衡循环扫描算法（C-LOOK） | CSCAN的改进，该方向没有请求，立刻放回最上面，开始:arrow_down: |                                              |      |



