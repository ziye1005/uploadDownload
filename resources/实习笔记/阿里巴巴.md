# 阿里影业

## 自我介绍

面试官您好，我是沙雪琪，现在是南京理工大学计算机院研二学生。本科毕业于南京邮电大学物联网学院，放弃本校保研资格，改考南理工。无论是本科还是硕士期间，都获得了满额的一等学业奖学金。研究生两年跟着导师做项目，接触数据库比较多，因此想从事数据开发方向。

参加的项目中主要负责数据库相关的有：HS效能数据服务系统，包括三个子系统：数据采集与预处理子系统涵盖了数据采集、文本多媒体日志数据的批量导入等。数据检索与应用子系统提供全文检索和个性化推荐等。存储与计算分析子系统将采集的数据规范化存储、分析、计算、查询，我主要负责的部分有：1.构建基于陆军武器装备数据的八大数据库（战斗部、武器弹药、装备、目标、毁伤试验、材料、弹药结构、环境综合数据库）设计其标签数据规范。支持多种数据类型导入图数据库，图数据库只能存储文本信息，因此存储的是文件和图片的HDFS位置。2.支持批量数据导入，对于满足格式的json和csv文件允许直接导入图数据库。3.提供图数据库增删改查图形化界面，允许高级别用户直接修改数据库。

另一个参与的项目是中医药疫病防治体系构建系统，和南京中医药大学合作，聚焦疫病古籍数据，构建疫病防治和方药应用体系图数据库，为疫情防控提供决策上的中医药理论与政策支持。我主要负责总体统筹、客户对接、前后端开发、图数据库构建等。这个项目本周给了我们一批古籍数据，有30余本，我们正在设计数据结构，将其导入图数据库。

其实一路以来，本科转专业也好，放弃保研也好，选择一个项目多的导师也好，都是想积极进取，努力拼搏，为自己谋一个更好的未来。以上，谢谢您的聆听。

## 研究生项目

```
springboot版本2.3.0.RELEASE
"vue": "2.6.10",
```

### Druid ：

高性能实时分析数据库，数据的内存化提高了druid的查询速度。

### Redis：

完全开源免费的key-value内存数据库，一个数据结构服务器



### MyBatis：

持久层的、轻量级的半自动化ORM框架，封装了所有jdbc操作以及设置查询参数和获取结果集的操作，支持自定义sql、存储过程和高级映射。

#{} 和 ${} 的区别是什么？
`${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换
`#{}`是 sql 的参数占位符，MyBatis 会将 sql 中的`#{}`替换为? 号

Dao 接口里的方法可以重载，但是 Mybatis 的 xml 里面的 ID 不允许重复。

Mybatis分页：MyBatis 使用 **RowBounds** 对象进行分页，它是针对 ResultSet 结果集执行的**内存分页，而非物理分页**；**(2)** 可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，**(3)** 也可以使用分页插件来完成物理分页。



### rabbitMQ：

消息队列中间件，处理分布式事务

保证消息的传输时可靠的，高可用的，支持多语言、多协议

## 流计算

Stream API可以极大提高Java程序员的生产力，这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。

##  大表数据查询怎么优化

1. 优化SQL语句、索引
2. 加缓存：redis等。
3. 主从复制、读写分离
4. 降低耦合度，分布式系统
5. 水平切分，将表拆分

## 面经

### mr、spark的shuffle有什么不同

**MR的shuffle分为：**

1. Map端的shuffle，主要是Partition、Collector、Sort、Spill、Merge几个阶段；
2. Reduce端的shuffle，主要是Copy、Merge、Reduce几个阶段。

但是MR的shuffle有一个很重要的特点：**全局排序**。

排序是一个很耗资源的一种操作，而且很多的业务场景，是不需要进行排序的。所以MR的全局排序在很多的业务场景中是一个非常耗资源而且无用的操作。

**Spark的shuffle（对排序和合并进行了优化）：**

提供了基于Hash的、基于排序和自定义的shuffleManager操作

### 一千万个整数，在5mb内存里排序

考虑能否一次读入内存，内存是否足够：

如果去重后数据可以放入内存，我们可以为数据建立字典，比如通过map，hashmap然后直接进行统计即可。当然在更新每条数据的出现次数的时候，我们可以利用一个堆来维护出现次数最多的前N个数据，当然这样导致维护次数增加，不如完全统计后在求前N大效率高。

如果数据无法放入内存。将字典存放到硬盘上，而不是内存，这可以参考数据库的存储方法。而我主要讲的分治策略是对常见复杂问题的一种万能的解决方法，虽然很多情况下，分治策略的解法都不是最优解，但是其通用性很强。 此处只讲解一个方法，即最常用的堆+hash：

从1亿个整数里找出100个最大的数 

#### 堆排序+hash

堆排序+hash：先对这批海量数据预处理，在O(N)的时间内用Hash表进行拆分映射
将需要排序的数据切分为多个**样本数大致相等**的区间，例如：1-100，101-300… 这里要考虑IO次数和硬件资源问题，例如可将小数据文件数设定为1G（要预留内存给执行时的程序使用） 
**读取每个小文件的前100个数字**，建立最大值堆。（这里采用堆排序将空间复杂度讲得很低，要排序1亿个数，但一次性只需读取100个数字，或者设置其他基数，不需要1次性读完所有数据，降低对内存要求） 
**依次读取余下的数，与最大值堆作比较，维持最大值堆**。可以**每次读取的数量为一个磁盘页面**，将每个页面的数据依次进堆比较，这样节省IO时间。 
将堆进行排序，即可得到100个有序最大值。
最后对各个数据区间内的排序结果文件进行处理，最终每个区间得到一个排序结果的文件，将各个区间的排序结果合并。

#### MR

MR：可以根据数据值或者把数据hash(md5)后的值，将数据按照范围划分到不同的机子，最好可以让数据划分后可以一次读入内存，这样不同的机子负责处理各种的数值范围，实际上就是map。得到结果后，各个机子只需拿出各自的出现次数最多的前N个数据，然后汇总，选出所有的数据中出现次数最多的前N个数据，这实际上就是reduce过程。这里拿上面的方法和trie树做一个比较：

### 堆和栈的应用场景

栈：栈是一种线性的数据结构，栈中的数据占用的内存空间的大小是确定的，便于代码执行时的入栈、出栈操作，并由系统自动分配和自动释放内存可以及时得到回收，相对于堆来说，**更加容易管理内存空间**。

堆：堆是一种树形数据结构，读取相对复杂。**堆是动态分配内存**，内存大小不一，也**不会自动释放**。栈中的数据长度不定，且占空间比较大。**便于开辟内存空间，更加方便存储**。



### spark计算的灵活性体现在哪里

易用性：可以用较多的编程语言来写我们的应用程序，（Java,[Scala](https://so.csdn.net/so/search?q=Scala&spm=1001.2101.3001.7020),Python,R 和 SQL）；Spark 为我们提供了超过80个高阶操作，这使得我们十分容易地创建并行应用

集成度高，以Spark为基础建立起来的模块(库)有**Spark SQL,Spark Streaming,MLlib(machine learning)和GraphX(graph)**

到处运行：Spark应用程度可以运行十分多的框架之上。它可以运行在Hadoop,Mesos,Kubernetes,standalone,或者云服务器上



# Neo4j

Neo4J使用Cypher Query Language(CQL)。

Neo4J中的节点, 关系, 属性和标签等构建块的作用是什么？
节点：它们是等同于表中行的实体。
关系：它连接实体和结构域。
属性：它包含元数据和属性。
标签：按角色分组节点。

哪些是流行的图形数据库
Oracle NoSQL  GraphBase, InfiniteGraph

解释Neo4J的一些功能
Neo4J将本机图形存储与本机GPE(图形处理引擎)结合使用。
Neo4J支持将查询数据导出为JSON格式。
Neo4J提供了REST API, 可通过Python py2neo, Java, Spring, Scala等任何编程语言进行访问。
Neo4J提供了Java脚本, 可以由任何UI MVC框架(如Node JS)访问。

如何在Neo4J中存储文件？
A：Neo4J将图形数据存储在许多不同的存储文件中, 每个存储文件都包含图形特定部分的数据, 例如关系, 节点, 属性等。

```
merge (n:`疟`:`疫`:`中毒`{name:'TestName'}) return n // 多标签
merge(n:`中毒`{name:'中毒'}) set n={`prp1`:'2123', `prop2`:'22',`name`:'中毒'} return n // 添加属性
match (n),(m:`%s`) WHERE id(n) = %d AND m.name = '%s' merge p=(n)-[r:属于]->(m) return p  // 增加n和m的属于关系
MATCH (n) WHERE id(n)=%d DETACH DELETE n // 删除节点和所有关系
MATCH ()-[r]-() WHERE id(r)=%d DELETE r // 删除关系
```

## Neo4j支持哪些

支持索引，支持事务ACID，支持遍历和查询，支持图算法（迪杰斯特拉，AStar）

## 优缺点

优点：

1、数据的插入，查询操作很直观，不用再像之前要考虑各个表之间的关系。
2、提供的图搜索和图遍历方法很方便，速度也是比较快的。
3、更快的数据库操作。当然，有一个前提条件，那就是数据量较大，在MySql中存储的话需要许多表，并且表之间联系较多（即有不少的操作需要join表）。

缺点：

1、当数据过大时插入速度可能会越来越慢。.
2、超大节点。当有一个节点的边非常多时（常见于大V），有关这个节点的操作的速度将大大下降。
3、数据库内存占用量，而是需要计算后为其”预留“内存…
注：鉴于其明显的优缺点，Neo4j适合存储”修改较少，查询较多，没有超大节点“的图数据。

# Python多进程、多线程、协程

| 类型                       | 优点                           | 缺点                                                         | 适用                                                         |
| :------------------------- | :----------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| 多进程，资源调度的基本单位 | 可以利用CPU多核并行运算        | 占用资源最多可启动数目比线程少                               | （CPU密集型计算<br />压缩解压缩、加密解密、正则表达式搜索）  |
| 多线程，CPU调度的基本单位  | 相比进程更轻量占用资源少       | 相比进程，多线程只能并发执行，不能利用多CPU（GIL）相比协程启动数目有限制，占用内存资源有限 | IO密集型计算、同时运行的任务要求不多                         |
| 多协程，用户调度的基本单位 | 内存开销最少，启动协程数量最多 | 支持库的限制代码实现复杂                                     | IO密集型计算（文件读写、网络爬虫、数据库读写）、同时运行的较多任务 |

Python的多线程是伪多线程，同时只能有一个线程运行。

一个进程能够启动N个线程，数量受系统限制。

一个线程能够启动N个协程，数量不受限制。

* 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,
进程是系统进行资源分配和调度的一个独立单位。
每个进程都有自己的独立内存空间，
不同进程通过进程间通信来通信。
由于进程比较重量，占据独立的内存，所以**上下文进程间的切换开销**（栈、寄存器、虚拟内存、文件句柄等）比较**大**，但相对比较稳定安全。

* 线程

线程是进程的一个实体, 是CPU调度和分派的基本单位,
它是比进程更小的能独立运行的基本单位.
线程**自己基本上不拥有系统资源**, 只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),
但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
**线程间通信主要通过共享内存**，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

* 协程

协程是一种**用户态的轻量级线程，协程的调度完全由用户控制**。
协程拥有自己的**寄存器上下文和栈**。协程调度切换时，将寄存器上下文和栈保存到其他地方，
在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

* 协程与线程进行比较

1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。
2) **线程进程都是同步机制，而协程则是异步**
3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态

简单的来讲就是在一个线程中的某个函数，
可以在任何地方保存当前函数的一些临时变量等信息，然后切换到另外一个函数中执行，
注意不是通过调用函数的方式做到的，并且切换的次数以及什么时候再换到原来的函数都由开发者自己确定   #(用户的调度单位)

# 面经

MySQL单表500w就会性能下降

解决hash冲突的方法：

开发定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）
再哈希法
拉链法
建立一个公共溢出区

亿万级数据优化：

1. 优化sql 和 索引
2. 加缓存redis
3. 主从复制或者主主复制，读写分离，可以在应用层做，效率高



# 反问

介绍下部门：飞猪数据组，涉及数仓、数据科学家、平开

这个岗位在贵公司的发展前景是怎样的，晋升路径是什么样子的？

与你们的预期相比，我有哪些不足？

贵公司对新入公司的员工有没有什么培训项目

