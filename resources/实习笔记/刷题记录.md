# tips

## 变量的命名

主流有如下三种变量规则：

- 小驼峰、大驼峰命名法：int myAge, int MyAge
- 下划线命名法：int my_ege
- 匈牙利命名法: int iMyAge 少用

![编程风格](https://camo.githubusercontent.com/91acd05c48f6ce04761d4e16802754991ad22930eadfd4ecbe1892c739ca1c81/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230313131393137333033393833352e706e67)

## 水平留白（代码空格）

标点后空格，前不空格；

变量和符号后空格；

大括号和 控制语句保持同一行的

({[后面不空格，]})前面不空格

## ACM模式

牛客网是ACM模式，自己构造输入数据格式，把要需要处理的容器填充好，OJ(Online Judge在线判题系统)不会给你任何代码，包括include哪些函数都要自己写，最后也要自己控制返回数据的格式。 

力扣上是核心代码模式，就是把要处理的数据都已经放入容器里，可以直接写逻辑。

public static void main(String[] args) {

```java
        Scanner in = new Scanner(System.in);
        while (!in.hasNext("#")) { // 多组测试手动输入，提交时变成in.hasNext()
            /*
3
this is a sentence
3.1214 testString
            * **/
            int a = in.nextInt(); // 读取int型
            in.nextLine(); // 吃掉换行符
            String aa = in.nextLine();// 读取一行字符串切割
            double b = in.nextDouble(); // 继续读数字
            String c = in.next(); // string不含空格和换行符
            
        int[] number = Arrays.stream(arrStr).filter(x -> x.length()!=0).mapToInt(Integer::parseInt).toArray();
        }

// 快读
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        String input1 = "";
        int row = 0;
        try{
            String r1 = in.readLine();  // int类型也需要readline，read一次只读一个数字，或者空格，或者换行符
            row = Integer.parseInt(r1);
            input1 = in.readLine() ;	// 读取一行数据
            
        }catch(IOException e){
            e.printStackTrace() ;	// 输出信息
        }
```



## 类型转换，基本+List+Set+queue

| 类型转换                                                     | 方法                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| int与Integer                                                 | **int a=A.intValue();**<br />Integer A = Integer.valueOf(a); |
| char与ascii                                                  | int(charA)<br />char(Inta)                                   |
| char/int/double/char[]转String                               | String ss = String.valueOf(new char[]{'c', 'b','a'})         |
| String转int/double/long                                      | int a = Integer.parseInt("1234");<br />double b = Double.parseDouble("12.3");<br />Long bb = Long.parseLong("23"); |
|                                                              |                                                              |
| list添加元素<br />==数组添加必须同类型==<br />嵌套list添加   | Collections.addAll(res,1,2,3);<br />**Integer**[] newInteger = {4,5,6}; Collections.addAll(res, newInteger);<br />Collections.addAll(rres, new ArrayList<>(Arrays.asList(1,2,3)), new ArrayList<>(Arrays.asList(12,23,34))); |
| queue<int[]>转为二维数组                                     | queue.toArray(new int  [ people.length ] [])                 |
| Array转List/Set （包装类型）                                 | 上面的数组添加，必须同是包装类型才能addAll                   |
| List/Set转Array int[]（基本）<br />Array String[]转Array int[] （基本） | int[] arrInt = integerList.stream().mapToInt(x -> x).toArray();<br />int[] arrInt = Arrays.stream(arrStr).mapToInt(x -> Integer.parseInt(x)).toArray(); |
| List/Set转Array（包装类型）                                  | Integer[] arrInteger = integerList.**toArray**(**new Integer[0]**);<br />String[] arr = stringList.toArray(new String[0]);<br />String[] setArr= setStr.toArray(new String[0]);<br />String[] strstr = Arrays.stream(input.split(" ")).filter(x-> x.length() != 0).**toArray(String[]::new)**; |
| Array求最大值Stream                                          | int resultMax = Arrays.stream(integers).reduce(0,Integer::max); // 静态方法引用 |
| Arrays.fill(chars,'.');                                      | 给一个char数组全部赋值'.'                                    |
| list<String>连接为string特定符号                             | String tt = String.join(".", tempList);                      |
| int[]数组或者list连接转string                                | String rr = Arrays.stream(arrRes).boxed().map(i -> i.toString()).collect(Collectors.joining(":")); |
| Array深拷贝                                                  | int[] arrCopy = Arrays.copyOf(arr, arr.length);              |
| 数字过大错误，将Integer改为Long，强制转换int为long           | long sum = (long) nums[one] + nums[two] + nums[three] + nums[four]; |
| StringBuffer                                                 | 可以直接连接char型，并且直接用index删除，toString转为String  |
| 正则表达式判断16进制                                         | String regex = "^(0X \| 0x \|) [0-9abcdef]*$"; return s.matches(regex); |
| 求数组最大值                                                 | Arrays.stream(nums).max().getAsInt();                        |
| split需要转义的字符                                          | **(   [   {   /   ^   -   $   ¦   }   ]   )   ?   \*   +   .**  都需要加双反斜杠，正则表达式也需要双反斜杠，replaceAll不需要 |
|                                                              |                                                              |

读取16进制：

```java
    public static String swap1(String a) {
        a = a.replaceAll("0x","").replaceAll("0X",""); // 读取16进制字符串
        BigInteger sint = new BigInteger(a,16); // 10进制
        String re2 = sint.toString(2); // 2进制
        String re8 = sint.toString(8); // 8进制
        String re16 = sint.toString(16); // 16进制
        return re2;
    }
```

split多种分隔符

```java
 String bb = "00(12[34]56)78";
        String[] arr = bb.split("[\\(, \\), \\[, \\] ]");
        System.out.println(Arrays.stream(arr).collect(Collectors.joining("\n")));
```



## Map

| Map                                                  | Set                                  |
| ---------------------------------------------------- | ------------------------------------ |
| HashMap<Character, Integer[]> map = new HashMap<>(); | Set<Integer> seen = new HashSet<>(); |
| map.put(key, value)                                  | seen.add(Integer e)                  |
| map.remove(key)                                      | seen.remove(Integer e)               |
| map.containsKey()                                    | test.contains()                      |
| map.containsValue()                                  |                                      |
| getOrDefault(key, defaultValue)                      |                                      |
| get(key)                                             |                                      |
| map.keySet()                                         |                                      |
| map.size()                                           | seen.size()                          |

```java
        // 1.迭代器+entrySet模式，安全删除且高效
        Iterator<Map.Entry<Integer,String>> iterator = map.entrySet().iterator(); // map.entrySet.iterator.var出来
        while (iterator.hasNext()) {
            Map.Entry<Integer,String> entry = iterator.next();
            if (entry.getKey() == 1 || entry.getKey() == 3)
            {
                iterator.remove();
            }
        }
        map.entrySet().removeIf(entry -> entry.getKey() == 1 || entry.getKey() == 3); // 也是迭代器
        iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer,String> entry = iterator.next(); // iterator.next.var出来
            System.out.println(entry.getKey() + ":" + entry.getValue());
        }
        System.out.println("-----------------------------------------");
        // 2.entrySet for循环模式，高效，不能删除
        for (Map.Entry<Integer, String> entry:map.entrySet()) { // map.entrySet.for直接出来
            System.out.println(entry.getKey() + "---" + entry.getValue());
        }
```



## 比较器

comparable是compareTo方法，是implement Comparable重写该方法，用于新定义class的排序，用的少一些

comparator是compare方法，在Collections.sort，Arrays.sort，PriorityQueue定义语句里面重写。
Comparator对**包装类型**的数组排序是很直接的，int[] []可以，Integer[]可以，String[]可以，但是**int[]不可以**

```java
PriorityQueue<int[]> priorityQueue = new PriorityQueue<int[]>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
//                先是比较value，由大到小排序;如果value相同，比较index，从小到大排序。
//                大value和小index更靠近队列头
//                大->小，大顶堆；小->大，小顶堆
                return o1[0] != o2[0] ? o2[0] - o1[0] : o1[1] - o2[1];
            }
        });
Comparator<Integer> comparator = new Comparator<Integer>() {
@Override
public int compare(Integer o1, Integer o2) {
// 升序排序是o1-o2，降序排序是o2-o1。
    return o1 - o2; // 原理：o1<o2,return -1;o1==o2,return 0;o1>o2return 1
}
};
Arrays.sort(points, (a,b) -> Integer.compare(a[0], b[0])); // 对于二维数组points，按照第一个元素小到大排序
Arrays.sort(points, (a,b) -> (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0])); // 对于二维数组，双排序
Collections.sort(listList, (a,b) -> a.get(1).compareTo(b.get(1)));// 对于List<List<string>>，按照str[1]升序排序
Collections.sort(aaa, (a,b) -> a.compareTo(b)); // 对于List<String>每个元素字典序正序
Collections.sort(aaa, (a,b) -> b.compareTo(a)); // 对于List<String>每个元素字典序倒序
Collections.sort(aaa, Integer.compare(y.length(),x.length())) // 长度的倒序排序
```

还有一种方法，使用stream排序，**基本类型**的倒序就很好处理了

```java
// 注: 要逆序排列的数组，不能使用基本数据类型，必须使用包装类型Integer,Double,Character,Byte
Arrays.sort(num, Collections.reverseOrder()); // num必须包装类型
int[] arrSort = Arrays.stream(intarr).boxed().sorted((x,y) -> y.compareTo(x)).mapToInt(x -> x).toArray();// 先boxed封装为Integer，再排序，再mapToInt转为int，再array
```



## 库函数的使用

**如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数**。

**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，那么直接用库函数。**

## 大厂开发流程

1. 需求文档

看需求文档，我们要根据需求文档来确定我们究竟要做什么。

一些同学可能感觉 为什么还要用一个需求文档呢，你就告诉我做啥我就做啥不就完事了。

其实需求文档一方面是倒逼产品经理去系统性的思考这个需求究竟有哪些功能，用来满足哪些用户的需求。

另一方面，是保证我们在研发的时候，研发出来的功能是满足需求文档里所描述的。

如果是口头对接的话，很有可能就是你做出来的东西，产品经理看完感觉：这和我说的需求不一样啊！！这和我想的不一样啊！！

这样就是两个人相互甩锅，那这究竟是谁的锅呢。都没有一个证据，对吧。

所以说，有一个需求文档很重要。

而且每个阶段的需求文档相当于是把这个项目的整个迭代过程都记录下来了。

这样也方便后面的人，了解这个项目是如何迭代的。

2. 这个需求包含了哪些功能

产品经理在需求文档里描述一个功能，那么我们在实现的时候，可能要改很多模块，或者说我们要增加一些模块。

就是我们从代码的角度上来讲，可能要增添很多功能才能满足 用户看起来好像微不足道的小功能。

我们要把产品经理角度上的这个功能，拆解为我们代码角度上的具体应该开发的那些功能。

3. 确定有哪些难点

要把自己的工作进行量化。那么这个功能有哪些难点，我们要克服这个难点，所需要花费的时间，都要有一个大体的量化。

这样才能量化我们自己的工作，**领导其实不知道你的工作是简单 还是困难, 领导只在意最终结果**，所以你要展现给领导你的工作是有难度的是有挑战的。

而且这些也是我们年底用来晋升或者评职称的素材。**确定了自己的工作难点，把这些难点都记录下来，对以后跳槽也很有帮助**。

面试官最喜欢问的问题，就是：**你做的项目中有哪些难点？以及你是如何克服的**。

4. 画架构图

一般来说，大厂项目的架构都是比较复杂的，特别是后端架构。如果添加一个模块连个文档都没有，连个图也没有，上来就添加的话，后面的人是很难维护的。而且每个模块和每一个模块之间的依赖关系，如果没有画出一个架构图的话，直接看代码很容易直接就看懵了。

为什么你可以快速开发一个新的模块，也是因为之前团队有人把这个架构图画清楚了，你只需要看一眼这个架构图，就知道你的模块应该添加在哪里。

那么你去添加模块的时候，也应该把这个架构图相应的位置 完善一下。

同时呢，在画架构图的过程中，也增添了自己对整个系统架构的掌握程度。

这个图也会让你确定，你的模块在整个项目中扮演一个什么样的角色。

5. 定协议

后台模块之间进行通讯需要协议，后台和前端通讯也需要协议。所以只要有交互，就要确定协议的数据格式。定协议要考虑到兼容，要考虑易于维护。

6. 设计数据结构和算法

其实设计数据结构更多一些，因为我们要选择使用什么容器，什么格式来处理我们的数据。至于算法的话，就很少我们亲自设计了。什么快排，二叉树，动态规划，最短路啥的，在实际开发中，都不需要我们自己去写，**直接调包！**

7. 预估一下容量

特别是后端开发，要估计出 我们自己模块大体需要多大磁盘，多大内存，多大带宽，多少核CPU。

这也是没有做过研发工作的同学经常忽略的，**因为大家好像默认 磁盘、内存、带宽、cpu是无穷的**。

其实我们在设计一个模块的时候，这些都要评估的，不能模块一上线，把机器直接打爆了，例如 直接把带宽打满了，不仅影响自己的模块功能，还影响了机器上其他模块的运行。

8. 考虑部署

要考虑如果一台机器挂了（可能是硬件原因），那么我们的模块还能不能正常提供服务。

这就是考虑模块的容灾性，一般都是采用分布式，服务部署在三台机器上，一台如果挂了，还有其他两台提供服务。

还有就是要弹性可伸缩，即我们的模块可不可以直接 部署多台机器来提高承载能力。

如果用户量突然上来了，或者流量突然上来了，可以通过快速部署多台机器来抗住流量。而不是模块只能在单机上跑，多部署几台就发生各种问题。

**这才能说明是有足够强的风险意识的**。

9. 设计评审

前八的阶段其实都是设计阶段，那么你的设计需要让组里的同学一起来评审一下，看看有没有什么问题。

大家主要也是看看你的模块 会不会给其他模块或者整个系统带来什么问题 以及 设计的是否合理。

10. 写代码

终于到写代码的阶段了，其实到这时候，是最容易的。

**写代码就是体力活了，不是脑力活了**。

11. 自测

写完代码，我们需要自测，自己的功能会不会有什么问题。

这里可能需要自己造一造数据，跑一跑 看看和预想的是不是一样的。

12. 联调

自己的模块可能会涉及到其他模块之间的一个交互，或者和前端的一个交互。

所以需要其他同学配合一起来测试。

这里就有很多沟通工作了，因为其他同学可能手头有自己的活，那么就要协调一个时间来一起测试。

这一步也是很费时间的，其费时关键是要等，要等其他同学有空和你联调，而且往往不是联调一次就能解决问题的。

所以 在评估开发时间的时候 也要考虑到联调的时间。

这也是大厂研发效率低的地方，但上百人开发的项目，这种沟通上消耗也是在所难免的。

13. 交给测试

自己的代码，自己测 一般都测不出什么问题，需要交给测试同学来给你测一测。

这里如果测试同学测出问题，你就要判断确实有问题还是 测试方式不对，如果有问题就要修改，在提给测试，反反复复这么几轮，直到测试同学测试没问题了。

14. code review

代码合入主干之前，需要 项目组的同学一起来评审一下你的代码。

之前是评审设计，看设计上有没有什么缺失，这次是大家来看看你代码写的怎么样。

例如合入主干会不会有什么问题，代码兼容性做的好不好，接口设计的好不好，甚至字段，函数，变量名，命名合不合理。

都要经过大家的评审，如果有问题就还是要改。

如果没有问题一般 大家会给+2（就是通过的意思），这样就可以合入主干了。

15. 合入主干

经常是自己的代码没问题，但合入主干之后就有问题了。

一般就是合入主干的时候有冲突，例如你从主干拉出一个分支，另一个同学从主干拉出一个分支，而且两个分支修改了同一个模块，如果另一个同学提前合入主干，你在合入主干的时候就会有代码冲突。

在解决代码冲突的时候 就会修改别人的代码，这个过程很容易产生新的bug。

**一般合入主干之后，测试同学还要重新跑一个全量测试，才能放心发布**。

16. 发布

发布其实就是把主干的代码更新到线上的服务器上。

用大白话来讲，就是把 本地的代码或者某台机器的代码，编译成可执行文件，然后更新到 线上的服务器（一个独立的集群，专门处理线上的流量）并运行起来。

上线是最重要的一步了，也很容易出问题，因为一个大型项目，其上线的过程都非常复杂（要更新上百台机器的集群），而且要考虑线上新版和旧版本的兼容问题。

这也是为什么大厂项目都选择深夜上线，**因为深夜在线用户最少，如果出问题，影响的用户会比较少，可以快速修复**。

所以大家经常看到 某大厂程序员深夜上线发布版本之类的。

## 时间复杂度

时间复杂度就是用来方便开发者估算出程序运行的答题时间。

估计程序运行时间：通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认CPU的每个单元运行消耗的时间都是相同的。

**大O用来表示上界的**，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

数据用例的不一样，时间复杂度也是不同的，这一点是一定要注意的。

一般OJ（online judge）的超时时间就是1s

## 不同语言的内存消耗

- C/C++这种内存堆空间的申请和释放完全靠自己管理
- Java 依赖JVM来做内存管理，不了解jvm内存管理的机制，很可能会因一些错误的代码写法而导致内存泄漏或内存溢出
- Python内存管理是由私有堆空间管理的，所有的python对象和数据结构都存储在私有堆空间中。程序员没有访问堆的权限，只有解释器才能操作。

为什么会有内存对齐：

1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了**同一个程序可以在多平台运行，需要内存对齐**。
2. 硬件原因：经过内存对齐后，**CPU访问内存的速度大大提升**。

## 语句

```
System.out.println(Arrays.toString(table));
hashmap.getOrDefault(Object key, V defaultValue)
```

# 数组

数组是存放在**连续内存空间**上的**相同类型数据**的集合。

在 **O(1)** 时间复杂度内存取元素。可以方便的通过下标索引的方式获取到下标下对应的数据。下标从0开始

数组的元素是固定长度的，**不能删除，只能覆盖**。

java默认是boolean型是false，int是0，*Integer的默认值为null*。

Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况。

​    int ans = Integer.MAX_VALUE;



```
 Arrays. binarySearch(sums, targetSum):对于已排序的数组sums生效，
1.targetSum属于sums，返回索引位置[0, length-1]；
2.targetSum不属于sums但在(sums[0],sums[length-1])区间，返回-插入点索引；[-2,-length],-length表示应该插入为倒数第二
3.targetSum < sums[0]，返回-1；
4.targetSum > sums[length-1],返回-(length+1)
负数都是直接用的索引，负数都是绝对值-1为索引

```

## 二分法

二分查找

[数组：每次遇到二分法，都是一看就会，一写就废](https://programmercarl.com/0704.二分查找.html)

这道题目呢，考察数组的基本操作，思路很简单，但是通过率在简单题里并不高，不要轻敌。

可以使用暴力解法，通过这道题目，如果追求更优的算法，建议试一试用二分法，来解决这道题目

- 暴力解法时间复杂度：O(n)
- 二分法时间复杂度：O(logn)

在这道题目中我们讲到了**循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

**二分法是算法面试中的常考题，建议通过这道题目，锻炼自己手撕二分的能力**。

## 双指针法

- [数组：就移除个元素很难么？](https://programmercarl.com/0027.移除元素.html)

双指针法（快慢指针法）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

```
int slow = 0;
for (int fast = 0; fast < nums.length; fast ++) {
    if (val != nums[fast]) {
        nums[slow] = nums[fast];
        slow ++;
    } // 如果==目标元素，slow不动，也就相当于移除了
}
```

在不改变顺序的情况下

- 暴力解法时间复杂度：O(n^2)
- 双指针时间复杂度：O(n)

## 滑动窗口

长度最小子数组

- [数组：滑动窗口拯救了你](https://programmercarl.com/0209.长度最小的子数组.html)

本题介绍了数组操作中的另一个重要思想：滑动窗口。

- 暴力解法时间复杂度：O(n^2)
- 滑动窗口时间复杂度：O(n)

本题中，主要要理解滑动窗口如何移动 窗口起始位置，达到动态更新窗口大小的，从而得出长度最小的符合条件的长度。

**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

如果没有接触过这一类的方法，很难想到类似的解题思路，滑动窗口方法还是很巧妙的。

```
// 滑动窗口，保证窗口内的sum>= target，快慢指针，当sum>=target，slow移动
    public static int minSubArrayLen(int s, int[] nums){
        int slow = 0, sum = 0;
        int res = Integer.MAX_VALUE;
        for (int fast = 0; fast < nums.length; fast ++) {
            sum += nums[fast];
            while (sum >= s) { // 当滑动窗口的sum达到target，记录长度后将slow移除，slow++
                res = Math.min(res, fast - slow + 1);
                sum -= nums[slow];
                slow ++;
            }
        }
        return res == Integer.MAX_VALUE ? 0: res;

    }
```

## 模拟行为

螺旋数组

- [数组：这个循环可以转懵很多人！](https://programmercarl.com/0059.螺旋矩阵II.html)

模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。

在这道题目中，我们再一次介绍到了**循环不变量原则**，其实这也是写程序中的重要原则。

相信大家有遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，拆了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，其实**真正解决题目的代码都是简洁的，或者有原则性的**，大家可以在这道题目中体会到这一点。

# 链表

单链表：单链表中的指针域只能指向节点的下一个节点。入口节点称为链表的头结点也就是head。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。支持前向&后向查询

循环链表：首尾相连，可以用来解决约瑟夫环

链表在内存中不是连续分布的，通过指针域的指针链接在内存中各个节点。

在找到指定位置后，链表插入和删除的时间复杂度是O(1)

![链表-链表与数据性能对比](https://camo.githubusercontent.com/3e831faf3c8a117995f352f7aab9a3314c6731d51a8e956e31847d59b04da6a5/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303830363139353230303237362e706e67)



## 带虚拟头节点的单链表的插入、删除、索引查询



插入到index前，与删除index元素，都是定位到前一个pre

```
// 插入
while (index-- > 0) {
    pre = pre.next;
}
ListNode q = pre.next;
pre.next = insertNode;
insertNode.next = q;
this.size++;
```

```
// 删除
while (index-- > 0) {
    pre = pre.next;
}
if (pre.next != null) {
    pre.next = pre.next.next;
    this.size--;
}

```

索引index元素，直接定位到该元素

```
// 查找索引
while (index-- >= 0) {
    if (pre.next == null) { // 对于超出长度的
return -1;
     }
     pre = pre.next;
}
if (pre != null) {
 	res = pre.val;
}
```

## 带虚拟头节点的双链表的插入、删除、索引查询

|            | 插入                         | 删除                      | 查询                           |
| ---------- | ---------------------------- | ------------------------- | ------------------------------ |
| 单链表head | 定位到index之前，index-- > 0 | 之前，index-- > 0         | index上，index-- >= 0          |
| 双链表head | 定位到index之前，index-- > 0 | 之前，index-- > 0         | index上，index-- >= 0          |
| 双链表tail | index上，index++ <= size - 1 | 之后，index ++ < size - 1 | index上， index ++ <= size - 1 |

**succ = pred.next.next;pred = succ.prev.prev;**

```
// 插入
newInsert.prev = pred;
newInsert.next = succ;
pred.next = newInsert;
succ.prev = newInsert;
// 删除
if (index < size / 2) {
    pred = head;
    while (index-- > 0) {
	pred = pred.next;
    }
    succ = pred.next.next;
} else {
    succ = tail;
    while (index++ < this.size - 1) {
	succ = succ.prev;
    }
    pred = succ.prev.prev;
}
pred.next = succ;
succ.prev = pred;
size--;


```

## 反转链表

pre从null到完整，cur从完整到null

```
        ListNode pre = null;
        ListNode cur = head;
        ListNode temp = new ListNode();
        while (cur != null) {
            temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
```

## 两两交换链表中的节点

## 快慢指针

### 删除倒数第n个节点

虚拟头节点

一次遍历实现定位到size - n ，让fast先走n，等fast走到size,low走到size-n

### 相交链表

一重循环，O(m+n),相交点后的长度相同，假设相交点为x，其index分别为xA,xB.即len(A)-xA = len(B)-xB，即preA走过len(A)+xB,preB走过len(B)+xA即可相遇。 如果不相交，则会在len(A)+len(B)即全是null的地方相遇

```
        while (preA != preB) {
            preA = preA == null ? headB : preA.next;
            preB = preB == null ? headA : preB.next;
        }
```

### 环形链表入口

数学证明在里面

1.fast走2步，slow走1步。第一次相遇，f=s+nb,f=2s。slow走过n倍的环形长度。s = nb，从head开始，a+nb可以走到环入口。现在已经走了nb，让s再走a即可。所以相遇之时，fast定位到head

2.fast走1步，slow走1步。第二次相遇，fast走了a，slow走了a+nb两者相遇

# 哈希表

常见的三种哈希结构，数组，映射和集合。

**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

HashMap和HashSet都只能用包装类

![image-20230305201434154](https://gitee.com/ziye1005/test-typora/raw/master/imgTypora/image-20230305201434154.png)



## 有效的字母异位词，赎金信

1.若 s和 t 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

2.给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。不是子串问题，只需要得到出现与否以及出现次数。

**用数组可以作为简单的哈希表，或者用HashMap。**

## 两个数组的交集

输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**使用set保证唯一性。**

## 两数之和，四数相加，三数之和，四数之和

1.两数之和：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

**<font color='red'>必须在一次循环中完成map的添加和查找是否满足条件</font>**

**使用map查找是否存在的复杂度为O(1)**

```
for (int i = 0; i < nums.length; i++) {
            int temp = target - nums[i];
            if (map.containsKey(temp)) {
                res[0] = map.get(temp);
                res[1] = i;
                return res;
            } else {
                map.put(nums[i], i);
            }
        }
```

2.四数相加：给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

**前两个放一个map，后两个放一个map。两个map比较。**

3.三数之和：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 请你找出所有满足条件且**不重复**的三元组。

**set去重太麻烦了，不能用set。排序+循环+双指针**

4.四数之和：给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且**不重复的**四元组。

与三数之和类似，就是再加一重循环

# 字符串

## 反转字符串，I， II

1.编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

 2.给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。



## 反转字符串的单词

不用split,需要三步：去除多余空格，翻转字符串，反转单词，每一步都是o(n)时间复杂度

## KMP算法，字符串匹配问题，重复子串问题

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

# 栈和队列

Dueue的实现类：LinkedList、ArrayDeque、LinkedBlockingDeque

栈是头加头删，队列是尾加头删。

|                         | 函数                                                         | 说明                                                         | 作用              |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------- |
| 栈/队列/链表            | isEmpty                                                      | true or false,true表示为空                                   |                   |
| 栈                      | void **push**(int x)                                         | stack push                                                   | 栈头头部增加      |
| 栈                      | int **pop**()                                                | stack pop                                                    | 栈头头部删除      |
| 队列                    | void **offer**(int x)                                        | queue push尾部插入一个元素                                   | 队列尾部增加      |
| 队列                    | int **poll**()                                               | queue pop 查询并移除第一个元素                               | 队列头部删除      |
| 双端队列LinkedList      | *offerFirst(E e)*<br/>*offerLast(E e)*                       | JDK1.6版本之后，在头部添加； 特有方法   <br/>JDK1.6版本之后，在尾部添加； 特有方法 | offer = offerLast |
| 双端队列                | *int pollFirst()*：删除头； 特有方法<br/>int *pollLast()*：删除尾； 特有方法 |                                                              | poll = pollFirst  |
| 链表LinkedList          | void add(int x)                                              | 链表尾加，通用方法                                           | 链表尾部增加      |
|                         | *addFirst(E e)*：<br/>*addLast(E e)*：                       | 在链表头部插入一个元素； 特有方法<br/>在链表尾部添加一个元素； 特有方法 | add = addLast     |
|                         | void add(int index, int x)                                   | 指定位置插入                                                 |                   |
| 链表LinkedList          | int remove(), remove(x)                                      | 链表头删，  通用方法                                         | 链表头部删除      |
|                         | *removeFirst(E e)*：<br/>*removeLast(E e)*：                 | 删除头，获取元素并删除； 特有方法<br/>删除尾； 特有方法      |                   |
|                         | *peek()*                                                     | 获取第一个元素，但是**不移除**； 特有方法                    |                   |
| 优先级队列PriorityQueue | add(x)尾加，remove()，remove(x),<br/>offer(x),poll()         |                                                              |                   |
| 单调队列linkedList      |                                                              |                                                              |                   |

## 栈的应用

71.简化路径

给你一个字符串 `path` ，表示指向某一文件或目录的 Unix 风格 **绝对路径** （以 `'/'` 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（`.`）表示当前目录本身；此外，两个点 （`..`） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，`'//'`）都被视为单个斜杠 `'/'` 。 对于此问题，任何其他格式的点（例如，`'...'`）均被视为文件/目录名称。

请注意，返回的 **规范路径** 必须遵循下述格式：

- 始终以斜杠 `'/'` 开头。
- 两个目录名之间必须只有一个斜杠 `'/'` 。
- 最后一个目录名（如果存在）**不能** 以 `'/'` 结尾。
- 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 `'.'` 或 `'..'`）。

返回简化后得到的 **规范路径** 。

括号匹配，逆波兰式求值

1047.删除字符串中的所有相邻重复项

递归

## 队列的应用

[239] 滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
返回 滑动窗口中的最大值 。

使用PriorityQueue，重写compare函数，将最大值排序在队头，如果index超出则poll

[347] 前 K 个高频元素 排序问题

# 二叉树

满二叉树：全部填满，2^k - 1个节点，是完全二叉树的特例

完全二叉树：最后一层可以不满，但是必须从左边开始不缺节点，即最后一层h从左边开始有[1, 2^(h-1)]个节点

优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

二叉平衡树：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

二叉搜索树：有序树，如果节点的左子树不空，则左边节点小于根节点的值（递归小于）

**通过中序遍历二叉搜索树得到的关键码序列是一个递增序列**。

平衡二叉搜索树：是一棵空树，或是有序树（二叉搜索树），且它的左右两个子树的高度差的绝对值<=1(递归小于等于)

存储方式：链式存储（多用，方便递归）：left指针指向左节点，right指针指向右节点

​					顺序存储（数组）：**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

遍历方式：深度优先（前序、中序、后序，递归）

​					广度优先（层序遍历，队列）

高度和深度：

|                   |                                                              |             |
| ----------------- | ------------------------------------------------------------ | ----------- |
| 树的高度=树的深度 | =根节点的高度                                                |             |
| 树的最小深度      | **从根节点到最近的叶子节点的距离**                           |             |
| 节点高度          | 该节点到[叶子节点](https://so.csdn.net/so/search?q=叶子节点&spm=1001.2101.3001.7020)的最长简单路径边的条数。 | 叶节点高度0 |
| 节点深度          | 从根节点到该节点的最长简单路径边的条数                       | 根节点深度0 |

先序+中序，层序+中序，后序+中序均可以唯一确定一个二叉树，这三种组合均可以确定根节点

先序+后序在一些情况下无法唯一确定二叉树

## 二叉树的算法——递归解法

- 确定参数和返回值（如果给定函数与自己需要的返回值不同，需要新写一个递归函数）
- 确定终止条件（一般都是null时return 0 或者return null或者return）
- 确定单层递归逻辑（这里面要写递归算法）

| 问题                                   | 递归解法                                                     | 说明                                                         |
| -------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.深度优先遍历DFS()                    | if (root == null) return; <br>dfsList.add(root.val); <br/>DFS(root.left, dfsList);<br/> DFS(root.right, dfsList); |                                                              |
| 1.1前序遍历preorder()                  | if (root == null) return;<br>res.add(root.val); <br/>preorder(root.left,res);preorder(root.right,res); |                                                              |
| 1.2中序遍历                            | if (root == null) return;<br/>inorder(root.left,res);res.add(root.val); <br/>inorder(root.right,res); |                                                              |
| 1.3后序遍历                            | if (root == null) return;<br/>postorder(root.left,res);<br>postorder(root.right,res);res.add(root.val); |                                                              |
| 2.1最大深度                            | if (root == null) return 0; <br>return Math.max(maxDepth2(root.left), maxDepth2(root.right)) + 1; |                                                              |
| 2.2最小深度（根到叶子）                | 见下面                                                       | 需要考虑是不是叶子                                           |
| 3.完全二叉树节点数计算                 | 见下面，考虑完全二叉树的情况                                 |                                                              |
| 4.翻转二叉树invertTree()               | if (root == null) return null;<br /> **TreeNode left = invertTree(root.left);<br /> TreeNode right = invertTree(root.right); <br />root.left = right; root.right = left;** return root; |                                                              |
| 5.判断镜像对称isSymmetric调用checkSame | if (p == null && q == null) return true;<br /> if (p == null \|\| q == null) return false; <br />**if (p.val == q.val && checkSame(p.left, q.right) && checkSame(p.right, q.left))**     return true; | 如何实现left.right与right.left的递归判断的<br />**只检查root，不检查孩子** |
| 6.判断是否是高度平衡二叉树（双重递归） | public boolean isBalanced(TreeNode root) {     <br />if (root == null) return true;     <br />return (Math.abs(balancedHeight(root.left) - balancedHeight(root.right)) <= 1 **&& isBalanced(root.left) && isBalanced(root.right))**;<br /> }//递归调用自身<br /><br />  public int balancedHeight(TreeNode root) {<br />     if (root == null) return 0;   <br />  return Math.max(balancedHeight(root.left), balancedHeight(root.right)) + 1; <br />}// 求最大高度 | 主函数要返回boolean，但是递归函数是返回int高度的，所以在主函数中判断高度差是否<=1<br />主函数需要判断子树的高度差，也就是说主函数递归调用自身<br />**既检查root，又检查孩子** |
| 7.求根到叶子所有路径                   |                                                              | 主函数中定义LIst<String>数组，带到递归函数中传值<br />既然path不好回溯，那就带在递归参数里，让它自己回溯 |
| 8.路径总和是否等于target               | if (root == null) return false; <br />if (root.left == null && root.right == null) {    <br /> return targetSum== root.val; <br />}<br /> return (hasPathSum(root.left, targetSum - root.val) \|\| hasPathSum(root.right, targetSum - root.val)); | 虽然像上一题，但是可以简化，不记录路径，只记录target-root.val |
| 9.左叶子之和                           | 见下面                                                       | 叶子好判断，但是如何判断左右叶子：通过节点的父节点以及孩子节点来判断本节点的属性。只有root.left == null时，加上ans； |

## 非递归算法

| 问题                                       | 解法                                                         | 说明 |
| ------------------------------------------ | ------------------------------------------------------------ | ---- |
| 1.前序遍历                                 | 非递归，用栈，入栈时读取，while (!stack.isEmpty() \|\| temp！=null) |      |
| 2.中序遍历                                 | 非常类似pre，只是在出栈时读取                                |      |
| 3.后序遍历                                 | 出栈依然不读取，若right为空 \|\| right已经访问，然后读取；否则，刚刚出栈的加回去 |      |
| 4.层序遍历                                 | 用队列LinkedList.offer,pull ，先入队root，出队时读取         |      |
| 5.层序遍历可以处理最大深度、最小深度的情况 |                                                              |      |
| 6.中序+后序构造二叉树                      | 定义全局变量后序的index_end，不断减减；追踪中序的left和right |      |
| 7.中序+先序构造二叉树                      | 定义先序的index_start，不断++；追踪中序的left和right         |      |

## 补充算法

### 最小深度递归

```
if (root == null) return 0;
//这道题递归条件里分为三种情况
//1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可
if (root.left == null && root.right == null) return 1;
//2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度
int m1 = minDepth2(root.left);
int m2 = minDepth2(root.right);
//这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;
if (root.left == null || root.right == null) return m1 + m2 + 1;

//3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可
return Math.min(m1, m2) + 1;
```

### 完全二叉树节点数统计

```
    //    6.2 考虑完全的情况 递归
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
//        这一行开始是对于完全二叉树的判断，如果是则用2^k - 1计算，否则则走普通二叉的最后一行
        TreeNode left = root.left;
        TreeNode right = root.right;
        int leftLen = 1, rightLen = 1;
        while (left != null) {
            left = left.left;
            leftLen++;
        }
        while (right != null) {
            right = right.right;
            rightLen++;
        }
        if (leftLen == rightLen) {
            return ((int) Math.pow(2, leftLen) - 1);
        }
        return countNodes(root.left) + countNodes(root.right) + 1;
    }
```

### 判断高度平衡的二叉树

```
/*
* [110]. 10.给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
* 1）确定参数与返回值：参数是root,root.left,root,right
* 想要知道高度差，那么返回值必须是int高度
* 2）确定终止条件：null节点返回高度0
* 3）最低层逻辑：左右子树均取最大高度 + 1，去主函数比较差值
* 4）注意点：要比较的不只是root的左右子树高度差<=1，需要每个子树都如此，所以主函数递归调用自身，同时调用求高度的函数
* */
public boolean isBalanced(TreeNode root) {
    if (root == null) return true;
    return (Math.abs(balancedHeight(root.left) - balancedHeight(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right));
}

public int balancedHeight(TreeNode root) {
    if (root == null) return 0;
    return Math.max(balancedHeight(root.left), balancedHeight(root.right)) + 1;
}
```

### 左叶子之和

```
    public int sumOfLeftLeaves(TreeNode root) {
        int ans = 0;
        if (root == null) return 0;
        if (root.left != null) {
            if (isLeafNode(root.left)) {// 是叶子就加上
                ans += root.left.val;
            } else {
                ans += sumOfLeftLeaves(root.left);// 不是叶子递归加上
            }

        }
        if (root.right != null ) {
            if (isLeafNode(root.right)) {// 是叶子不加上

            }
            else {
                ans += sumOfLeftLeaves(root.right); // 不是叶子递归加上
            }
        }
        return ans;
    }

    public boolean isLeafNode(TreeNode node) {
        return node.left == null && node.right == null;
    }
```

### 后序遍历非递归

```
    public List<Integer> postorderNoRec(TreeNode root) {
        LinkedList<TreeNode> stack = new LinkedList<>();
        ArrayList<Integer> res = new ArrayList<>();
        if (root == null)
            return res;
        TreeNode temp = root;
        TreeNode prev = null;
        while (!stack.isEmpty() || temp != null) {
            while (temp != null) {
                stack.push(temp);
                temp = temp.left;
            }
            temp = stack.pop();
            if (temp.right == null || temp.right == prev) {
//                如果temp的右节点为空，则该节点temp可以读取；
//                如果temp的右节点已经读过了，则temp可以读取
                res.add(temp.val);
                prev = temp;    //标记读过右节点
                temp = null;  // temp不往右走了，下一步是递归的return出栈
            } else {
//                右节点不为空 && 右节点没读过
//                把出栈的temp重新加回来，指向temp的右节点
                stack.push(temp);
                temp = temp.right;
            }
        }
        return res;
    }
```

### 构造二叉树

中序+后序：

1）参数：全局的post_idx为root，标记postorder的最后元素索引

​					全局的idx_map，标记in_order的value index对应

​					递归传参：in_left,in_right标记中序的起点终点，都是闭区间

2）终止条件：in_left> in_right return null

3）递归逻辑：取后序的post_idx处值，构造root节点；去in_order中找post_idx的index；**post_idx--**

​						用index去切割为inorder右子树[index + 1, in_right]，左子树[in_left, index - 1]

​						从而递归构造root的left和right，**先右子树后左子树**（因为左右中，右子树距离根节点倒序最近）

中序+先序与之类似，区别点：pre_index为root，**pre_index +**+；**先左子树再右子树**

[654] 最大二叉树构造二叉树：只有一个order，与之类似，求最大值作为root，从root的index去order中向左为左子树，向右为右子树

[108] 将有序数组转换为二叉搜索树：与之类似，但更简单，index=（left+right）/2

## 二叉搜索树

二叉搜索树：有序树，如果节点的左子树不空，则左边节点小于根节点的值（递归小于）

**通过中序遍历二叉搜索树得到的关键码序列是一个递增序列**。可以解决[530] 二叉搜索树的最小绝对差  以及 [501] 二叉搜索树中的众数

| 问题                              | 算法                                                         | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1.二叉搜索树中的搜索              | if (root == null) return null; <br />if (val < root.val) return searchBST(root.left, val); <br />if (val > root.val) return searchBST(root.right, val); |                                                              |
| 2.[98] 验证二叉搜索树             | if (root == null) return true;         <br />if (root.val <= min \|\| root.val >= max) return false; //        都是开区间         return isValidBSTCon(root.left, min, root.val) && isValidBSTCon(root.right, root.val, max); | 一定要记录min和max，因为需要递归的小于或者大于，这个界限会因为父亲的父亲而变<br />递归体用的是&& |
| 3.最小差值                        |                                                              |                                                              |
| 4.众数                            |                                                              |                                                              |
| 5.二叉树的最深公共祖先            | 见下面                                                       | 最深的公共祖先：p和q要么一个在左一个在右，要么公共祖先是p或者q |
| 6.二叉搜索树的最近公共祖先        | 比较简单，可以通过搜索找path，比较交点                       |                                                              |
| 7.二叉搜索树插入节点              | if (val < root.val) root.left = insertIntoBST(root.left, val); <br />else if (val > root.val) root.right = insertIntoBST(root.right, val); | 简单                                                         |
| 8.二叉搜索树删除节点              | if (key < root.val) root.left = deleteNode(root.left, key);<br /> else if (key > root.val) root.right = deleteNode(root.right, key); else if (key == root.val) {....} | 考虑左右都有孩子的情况，选择**右子树的最左节点**suc作为替补，**递归删除**suc，suc.right = root.right;suc.left = root.left |
| 9.修剪二叉搜索树                  |                                                              | 参考删除，但是可以简化，当root.val <low时,root.left直接没了，root = trimBST(root.right); |
| 11.[538] 把二叉搜索树转换为累加树 | if (root == null) return; <br />dfsRightInLeft(root.right);<br /> **sum += root.val; root.val = sum;** <br />dfsRightInLeft(root.left); | 反中序遍历（**右根左**），**<font color='red'>需要一个全局变量记录和</font>** |

## 补充算法2

二叉树的最深公共祖先

```
    TreeNode ans = null;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        dfs(root, p, q);
        return ans;
    }
    private boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) return false;
//        最深的公共祖先：p和q要么一个在左一个在右，要么公共祖先是p或者q
        boolean left = dfs(root.left, p, q);
        boolean right= dfs(root.right, p, q);
//       在left这一边找到了，并且在right这一边也找到了，说明root是公共祖先
//        root值等于p或q，并且找到了另一个，说明root是公共祖先
        if (left && right || ((root.val == p.val || root.val == q.val) && (left || right))) {
            ans = root;
        }
//        只要有一个满足，都说明出现了p或者q
        return (left || right || root.val == p.val || root.val == q.val);
    }
```

## 二叉树总结

### 递归总结

有递归的地方就一定用到了回溯，回溯就在递归的下面

1）确定返回值：如果主函数定义的返回值与递归返回值不一样，就新开一个递归函数

2）确定传递参数：最好是用return的方式return出来想要的参数【遍历，最小/最大深度，节点数计算，完全二叉树节点数计算，翻转二叉树，对称二叉树和相同的树判断】（高度，节点数，boolean，TreeNode）。

​		如果做不到，那就传参时候带着数组或int【验证二叉搜索树，二叉树根到叶子所有路径】（List<Integer> res, int min, int max）。

​		如果单纯的逐级传参做不到，那就定义为全局（sum）【四种构造二叉树，累加树】，在主函数中对sum初始化，在递归函数中调用sum

3）确定出口：一般都是root == null return null / 0

4）确定递归体，要分清楚return的值被谁接住了，尤其是，双重递归要注意【高度平衡二叉树】



递归过程中参数传递问题：

1）通过返回值；

2）数组传参可以不断修改数组

3）定义在类变量而不是函数变量里面

返回值是void只需要全局变化同样的参数，但是返回值是int，是需要return时候被接住，在每一重逻辑里，都是相同的处理（是不需要显式写回溯代码的，因为没有全局变化，即自己参数的变化除了返回值，不会影响上一级）。比如双重递归【路径总和III】

### 构造二叉树总结

后+中/前+中：递归传参只传中序的left和right

只要找到根，就可以切割

坚持区间不变原则，都使用左闭右闭

### 二叉搜索树总结

二叉搜索树是一个有序树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

通过**中序遍历二叉搜索树**得到的关键码序列是一个递增序列。

平衡二叉搜索树：是一棵空树，或它的左右两个子树的高度差的绝对值<=1(递归小于等于)

堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）但不是平衡二叉搜索树。 **但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树**。

### 其他

leetcode的题目中都是以节点为一度，即根节点深度是1

二叉树题目迭代法中究竟什么时候用队列，什么时候用栈？

**如果是模拟前中后序遍历就用栈，如果是适合层序遍历就用队列，当然还是其他情况，那么就是 先用队列试试行不行，不行就用栈。**

# 回溯搜索

回溯是递归的副产品，只要有递归就会有回溯。**回溯**函数也就是**递归**函数，指的都是一个函数。回溯法不高效，本质是**穷举**，顶多加上**剪枝**。所有回溯法的问题都可以抽象为**树形结构**。

返回void

回溯法，一般可以解决如下几种问题：

- 组合（不管顺序）：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列（强调顺序）：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

![回溯算法大纲](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)

## 组合问题

| 问题                                       | 解法                                                         | 备注                                                         |          |
| ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1.[1,n]中选k个                             | for (int i = start; i <=n ; i++) { // for循环代替了一次递归 //           <br /> //剪枝，add前判断           <br />  if (temp.size() + n - start + 1 < k)    // start > n 也算在这里面  return;            <br /> temp.add(i);             <br />**combineBackTrack(i + 1, n, k);**             <br />temp.remove(temp.size() - 1); // 加进去[1,2]然后return，此时 start = 3，所以可以继续往下走        <br >} | 剪枝在add之前，for循环+递归作为一重循环<br />递归传参i + 1是不重复取值 | 叶子回收 |
| 2.电话号码的字母组合                       | String tempDigit = map.get(digits.charAt(indexDigit));<br /> for (int i = 0; i< tempDigit.length(); i ++) {    <br />tempString.append(tempDigit.charAt(i));    <br />**backTrackLetter(indexDigit + 1);**    tempString.deleteCharAt(tempString.length() - 1); <br />// tempString回溯 } | 用StringBuffer方便add和delete<br />递归传参indexDigit + 1表示每个字母集只取一次，往后走 | 叶子回收 |
| 3.组合总和<br />无重复数组，但值可以重复取 | for (int i = startIndex; i < this.Candidates.length; i++) { <br />if (sum + Candidates[i] > Target) {  break; }  // 剪枝   <br />temp.add(Candidates[i]); //   i不增，表示可以重复使用candidates的元素             **backTrack(i, sum + Candidates[i]);**             <br />Temp.remove(Temp.size() - 1);         } | 排序，先排序<br />递归传参i不增，说明可以重复取值<br />递归传参sum + Candidates[i]是有回溯的 | 叶子回收 |
| 4.组合总和2<br />有重复数组，值不可重复取  | for (int i = startIndex; i <this.Candidates.length; i++) { <br />//  **<font color='red'>每一层只用一次，去重，只有在数组有序时可以这样去重</font>** <br />if (i >startIndex && this.Candidates[i] == this.Candidates[i -1]) { continue; } <br /> Temp.add(Candidates[i]); <br />//i+1,不重复使用candidates的元素             <br />backTrackCombinationSum2(i + 1, sum + Candidates[i]);             Temp.remove(Temp.size() - 1);         } | 排序，先排序<br />有重复值的要去重：**同一数层上同一个值只取一次**<br /> | 叶子回收 |
|                                            |                                                              |                                                              |          |
| 5.分割回文串                               | for (int i = startIndex; i < sixLen; i++) {        <br /> if (judgeHuiwen(startIndex, i)) {              **sixTest.add(sixS.substring(startIndex,i + 1));             <br />sixBackTrack(i + 1);**             <br />sixTest.remove(sixTest.size() -  1);         <br />}     } } | 与组合差不多，组合是用数字组成的list，回文串是String的list<br />每次取得是**[startIndex,i]**的闭区间 | 叶子回收 |
| 7.复原IP地址，加'.'                        | for (int i = startIndex; i < seven.length(); i++) {     <br />String inFor = seven.substring(startIndex, i + 1);    <br /> if (checkIll(inFor)) {           <br /> **<font color='red'>sevenBackTrack(i + 1, sevenTemp + inFor + ".", sevenTime + 1);</font>**        < } | 与回文串分割差不多，但是注意终止条件<br />加的'.'个数用sevenTime 回溯，sevenTemp + inFor + "."回溯 | 叶子回收 |
| 8.子集                                     | eightRes.add(new ArrayList<>(eightTemp)); // **收集所有节点，而不仅仅是叶子节点** <br />for (int i = startIndex; i < eightLen; i++) {     <br />eightTemp.add(eightNums[i]);     <br />eightBackTrack(**i + 1**);     <br />eightTemp.remove(eightTemp.size() - 1); } | 在递归开始就回收，没有条件<br />子集问题没有终止条件return，因为所有都需要遍历 | 每层回收 |
| 9.重复数组子集                             | if (i > startIndex && nineNums[i] == nineNums[i - 1]) {     continue; } | **先排序；<br />for循环内部加上去重判断**                    | 每层回收 |
| 10.递增子序列                              | HashSet<Integer> set = new HashSet<>();<br />for (int i = startIndex; i < TenNums.length; i++) { <br />if (!tenTemp.isEmpty() && TenNums[i] < tenTemp.getLast()) { continue; }<br /> if (set.contains(TenNums[i])) {         continue;     }     tenTemp.add(TenNums[i]);     <br />**set.add(TenNums[i]); // 因为在递归体内，不需要set.remove** tenBacktrack(i + 1);     <br />tenTemp.removeLast(); } | 不能排序了，原数组不是有序的<br />可以**在递归内**定义set<br />**不是全局不是全局，是针对每一数层（递归体内）而不是每一树枝** | 每层回收 |
|                                            | 排列与前面不同，不需要传参index或index+1，但是需要全局used数组 | used[i - 1] == true，说明同一树枝nums[i - 1]使用过 <br />used[i - 1] == false，说明同一树层nums[i - 1]使用过，用于有序数组去重<br />userd[i] ==false,说明这一树枝没用过i，用于递归 |          |
| 11.全排列                                  | if (**!EleUsed[i]**) {    <br /> EleTemp.addLast(EleNums[i]);     <br />**EleUsed[i] = true;**     <br />**EleBackTrack();**    <br />EleTemp.removeLast();    <br /> **EleUsed[i] = false;** } | **used是全局是全局。**递归不传参，递归和回溯改变used的值     | 叶子回收 |
| 12.重复数组全排列                          | if (i > 0 && EleNums[i] == EleNums[i - 1] && !EleUsed[i - 1]) {     continue; } | for循环内递归前加上这个，可以去重<br />EleUsed[i - 1] == false 数层去重 | 叶子回收 |
| 13.重新安排行程                            | if (findPath(tickets, ticketLength, used)) {     <br />//找到的第一个就是答案，不能往下找了     <br />return true; } | 重点在于找到一个就直接返回，因为返回值是boolean，一定要返回，否则就不对了 |          |
| 14.N皇后                                   | for (int col = 0; col < fourN; col ++) {     <br />if (subValid(row, col, chessBoard)) {         <br />chessBoard[row][col] = 'Q';       // 加上  <br />queenBackTrack(row + 1, chessBoard);         //递归<br />chessBoard[row][col] = '.';     } } // 回溯 | 有效性判断,只需要判断左上右上行和列 <br /> 每一层是一个row,每一层的宽度是col,一维递归:只需要一层for遍历列+一层递归遍历行 | 叶子回收 |
| 15.数独                                    | 见下面                                                       | 三重for循环+递归(行+列+值+递归) <br />判断条件:行+列+九宫格,没有对角线<br />判断函数里面不要优化不要优化 |          |



## 补充算法

### N皇后

```
List<List<String>> fourRes = new ArrayList<>();
int fourN;
public List<List<String>> solveNQueens(int n) {
    this.fourN = n;
    char[][] chessBoard = new char[n][n];
    for (char[] chars : chessBoard) {
        Arrays.fill(chars,'.');
    }
    queenBackTrack(0, chessBoard);
    return fourRes;

}
void queenBackTrack(int row, char[][] chessBoard) {
    if (row == fourN) {
        List<String> fourTemp = new ArrayList<>();
        for (char[] chars : chessBoard) {
            fourTemp.add(String.valueOf(chars));
        }
        fourRes.add(fourTemp);
        return;
    }
    for (int col = 0; col < fourN; col ++) {
        if (subValid(row, col, chessBoard)) {
            chessBoard[row][col] = 'Q';
            queenBackTrack(row + 1, chessBoard);
            chessBoard[row][col] = '.';
        }
    }

}
```

### 解数独

```
boolean shuduBackTrack(char[][] board) {
    for (int i = 0; i < board.length; i++) { // 行
        for (int j = 0; j < board[i].length; j++) { // 列
            if (board[i][j] != '.') { // 跳过原始数字
                continue;
            }
            for (char k = '1'; k <= '9'; k++) { // 遍历char值
                if (shuduValid(i, j, k, board)) {
                    board[i][j] = k; // 加上
                    if (shuduBackTrack(board)) {
                        return true; // 返回处有讲究
                    }
                    board[i][j] = '.'; // 回溯去掉
                }
            }
            return false;                // 9个数字都试完了都不行,那就返回false
        }
    }
    return true; // 遍历到最后都没有中间退出,说明找到了
}
```

## 回溯总结

组合，分割，排列，子集，棋盘

返回值一般是void（特殊：数独）

定义全局res数组

定义tempRes存储当前，可以作为全局，最好还是回溯里面（IP地址）

**<font color='red'>for循环+递归比较好理解：</font>for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

剪枝精髓是：**for循环在寻找起点的时候要有一个范围**，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了。

for内add前剪枝

组合：一般需要**startIndex**来控制for循环的起始位置，收集叶子；

​			**排序之后加剪枝是常见的套路！**

去重：

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过（排列里面下一层）
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过（排列里面重复项）
- 有序数组重复项去重（组合）可以用i > startIndex和used数组
- 非有序数组重复项去重（数层去重）可以用递归内的set
- **<font color='red'>排列树枝去重也需要排序后才能使用used数组</font>**



# 贪心算法

贪心的本质是选择每一阶段的**局部最优，从而达到全局最优**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

贪心算法的子问题分解需要细致寻找题目自身蕴含的规律

**贪心是常识，有些常识并不容易，甚至很难！**

| 问题                               | 解法                                                         | 备注                                                         | 题型     |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1. [455] 分发饼干                  | 排序饼干和胃口，一重循环先遍历胃口，再遍历饼干               | 可以排序的，会比较简单                                       | 简单     |
| 2.[376] 摆动序列                   | 删除单调坡度上的节点（不包括单调坡度两端的节点）             |                                                              | 思想     |
| 3.[53] 最大子数组和                | **当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”** | 子数组子序列都不能排序                                       | 思想     |
| 4.[122] 买卖股票的最佳时机 II      | **利润拆分**：只收集每天的正利润                             |                                                              | 思想     |
| 5.[55] 跳跃游戏判断能否到末尾      | i对i的cover循环，更新cover                                   |                                                              | 区间     |
| 6.[45] 跳跃游戏 II判断最小跳跃次数 | 仍是利用cover，但是分为了这一跳的cover和下一跳的cover        |                                                              | 区间     |
| 7.[1005] K 次取反后最大化的数组和  | 区分正数、负数和0                                            |                                                              | 简单     |
| 9.[135] 分发糖果                   | 两个维度必须先选择一个：从前往后，判断后一个的rating是不是比前一个大；从后往前，判断前一个的rating是不是比后一个大 | 多维度或者双维度必须先确定一个                               | 两个维度 |
| 11.[406]根据身高重建队列           | 根据身高大->小排序，根据k作为index插入，直接可以得到结果     | 使用LinkedList做插入操作比较快，最后转化为二维数组queue.toArray(new int [ people.length ] []) | 两个维度 |
| 12.[452] 用最少数量的箭引爆气球    | 可以左边界正排序，也可以右边界正排序，但右边界正排序更合适，因为每次取的箭入点是右边界 |                                                              | 区间     |
| 13.[435] 无重叠区间                | 依然右排序合适，记录右边界，有重叠则删掉，没有重叠更新右边界 |                                                              | 区间     |
| 15.[56] 合并区间                   | 左边界排序更好，避免出现 [ 2,3] [3,4 ] [1,10]就合并不了      |                                                              | 区间     |
| 16.[763] 划分字母区间              | map找到每个字母最后出现位置索引                              |                                                              | 区间     |
| 16.[738] 单调递增的数字            | 转化为String处理，不需要考虑借位情况：一旦首位为0，parseInt自动变的 <br />从个位->高位扫描，一旦前一位i-1>后一位i，前一位(i-1位)-1，从其后i位置开始变成9 | 思想不好想                                                   | 思想     |
| 17.[968] 监控二叉树                | 后序遍历，三种节点状态                                       |                                                              | 思想     |

# 动态规划

动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

动规里面有多个维度且多维度有制约关系

五个步骤：

1. 确定dp数组（dp table）以及下标的含义

2. 确定递推公式（状态转移公式）
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

debug方法：打印DP数组

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的**递归公式、初始化或者遍历顺序**有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

## 基础算法

| 问题                   | 解法                                                         | 备注     |
| ---------------------- | ------------------------------------------------------------ | -------- |
| 1.[509]斐波那契数列    | dp[i]表示第i个斐波那契数的数值dp[0] = 0, dp[1] = 1,dp[2] = dp[0] + dp[1] = 1<br />dp[i] = dp[i - 1] + dp[i - 2] | 简单推导 |
| 2.爬楼梯               | dp[i]表示第i级台阶的方法数dp[1] = 1, dp[2] = 2,dp[3] = dp[1] + dp[2] = 3<br />状态转移公式：dp[i] = dp[i - 1] + dp[i - 2] |          |
| 3.最小花费爬楼梯       | dp[i]表示到达第i级台阶需要的最小cost dp[0]=0,dp[1]=0<br />dp[i] = Math.min(dp[i - 1] + cost[ i - 1], dp[i-2] + cost[i-2]); |          |
| 4.不同路径（机器人）   | 初值：0行0列赋值为1；dp[ i ] [ j ] = dp[ i - 1 ] [ j ] + dp [ i] [ j - 1];（只能右下移动，所以是左边的+上面的） |          |
| 5.不同路径II（有障碍） | 初值：有障碍在首行首列其后为0不为1；有1的路径不走            |          |
| 6.整数拆分             | 可以不用动规                                                 |          |
| 7.不同的二叉搜索树     | 见下面                                                       |          |

```
/**
 * 不同的二叉搜索树
 */
public int numTrees(int n) {
    //初始化 dp 数组
    int[] dp = new int[n + 1];
    //初始化0个节点和1个节点的情况
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            //对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加
            //一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j
            dp[i] += dp[j - 1] * dp[i - j];
        }
    }
    return dp[n];
}
```

## 背包问题

只需要掌握01背包（选0选1）和完全背包（选0选多）

01与完全的区别：背包的遍历倒序/正序

组合和排列的区别：先物品/先背包

![416.分割等和子集1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407.png)

0-1背包：

dp数组：dp[SumWeight+1] dp[0] =0

遍历顺序：先物品正序 i:[0, nums.length)，再背包**倒序j**:[SumWeight, nums[i] ]

返回结果：dp[SumWeight]

装满背包最大价值：dp[j] = max(dp[j], dp[ j-weights[i] ] + value[i])

背包能否装满：判断求出来的dp[SumWeight]

装满背包的组合方法数 ： dp[0] = 1  **dp[j] += dp[j-nums[i] ]**

装满背包最多用多少物品：dp[j] = max(dp[j], dp[j - weights[i] ] + 1)

装满背包最少用多少物品：dp初始化为Integer.MAX_VALUE dp[0] = 0  dp[j] = min(dp[j], dp[j - weights[i] ] + 1)

**<u>==*0-1背包问题应用*==</u>**

| 问题                                                         | 解法                                                         |
| :----------------------------------------------------------- | ------------------------------------------------------------ |
| 分割等和子集：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 | 0-1背包装满：容量为sum / 2的背包的最大价值                   |
| [1049] 最后一块石头的重量II：                                | 0-1背包装满：sum - 2*dp[sum  / 2]                            |
| 目标和：给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 | left + right = sum,left-right=target,left = (sum + target)/ 2 装满背包有多少种方法 |
| [474].一和零 ：给你一个二进制字符串数组 strs 和两个整数 m 和 n 。请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。 | 装满一个二维背包m0 n 1最多用多少物品                         |
|                                                              |                                                              |
| 零钱兑换：计算并返回可以凑成总金额所需的 最少的硬币个数 。每种硬币的数量是无限的 | 完全背包装满背包的最少物品数                                 |
| 零钱兑换II：计算可以凑成总金额的硬币组合数                   | 完全背包 装满背包的方法数：组合问题先物品在背包              |
| 377. 组合总和 Ⅳ 一个由正整数组成且不存在重复数字的数组，找出和为target正整数的组合的个数。顺序不同算两个 | 完全背包装满背包的方法数：排列问题先背包再物品               |
| 完全平方数：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 | 完全背包装满背包的最少物品数                                 |
| [139]单词拆分：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 | 能否装满背包s字符串                                          |

**<u>==*完全背包问题应用*==</u>**

完全背包：每个物品可以无限次选取

dp数组：dp[SumWeight+1] dp[0] =0

遍历顺序：先物品正序 i:[0, nums.length，再**背包正序j**:[nums[i] , SumWeight]

返回结果：dp[SumWeight]



装满背包最少用多少物品：**初始化dp为MAX  dp[0] = 0**  dp[j] = min(dp[j], dp[j-nums[i]] + 1)

装满背包的方法组合数：dp[0] = 1  **dp[j] += dp[j-nums[i] ]**

装满背包的方法排列数：dp[0] = 1  dp[j] += dp[j-nums[i] ]    **<font color='red'>先背包[1,sumWeight]再物品[0, nums.length)</font>**

**<u>==*单词拆分*==</u>**

```
/**
     * [139] 单词拆分
     * 1）dp[j]：s中长度为j的是否可以由字典拼接出来
     * 2）
     * 3）dp[0]表示长度为0的能否由字典拼接，默认为true
     * 4）是排列，先遍历背包（背包由1开始遍历，至少由1开始，因为dp[0]赋初值了），再遍历字典（字典由0开始）
     *
     * */
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        int sumWeight = s.length();
        boolean[] dp = new boolean[sumWeight + 1];
        dp[0] = true;
//        排列情况，apple pen的字典支持penpenapple,applepenpen,penapplepen
        for (int j = 1; j <= sumWeight; j++) { // 遍历背包
            for (int i = 0; i < j && !dp[j]; i ++) { // 遍历物品
//                选取s[i,j)这一段j-i长度的字符串，检查是否在字典中，
//                && !dp[j]是为了简化，如果找到了一个，则i不继续找了
                String temp = s.substring(i, j);
                if (set.contains(temp) && dp[i]) {
//                    如果s[i,j)在，且s[0,i)在，则说明s[0,j)长度为j的在里面
                    dp[j] = true;
                }
            }
        }
        return dp[sumWeight];

    }
```

## 打家劫舍

```
1)含义：dp[j]:前j间房子最大的偷盗数量
2）初始化：dp[0] = 0;dp[1] = nums[0];
3）递推式：dp[j] = Math.max(dp[j - 1], nums[ j - 1] + dp[ j - 2]);
4）循环：j[2,length]
dp[length]
```

打家劫舍II 首尾不能连

```
两次取大
No1:偷nums[0]
	dp[0] =0,dp[1] = nums[0]
	j:[2,len-1]
	返回dp[len-1]
No2:不偷nums[0]
	dp[0] = 0, dp[1] =0
	j[2, len]
	返回dp[len]


```

打家劫舍III 树形父子不相连 回溯吧，用map减少一部分计算

```
    public int rob3Back(TreeNode root) {
        if (root == null) return 0;
        if (root.left == null && root.right == null) return root.val;
        if (map.containsKey(root)) return map.get(root);
        // 不偷父节点
        int val1 = rob3Back(root.left) + rob3Back(root.right);
//        偷父节点
        int val2 = root.val;
        if (root.left != null) {
            val2  = val2 + rob3Back(root.left.left) + rob3Back(root.left.right);
        }
        if (root.right != null) {
            val2  = val2 + rob3Back(root.right.left) + rob3Back(root.right.right);
        }
        map.put(root, Math.max(val1, val2));
        return Math.max(val1, val2);
    }
```

## 股票问题

股票I

一次买卖，一天买入，另一天卖出

1）定义：dp[i] [0]第i天持有的现金（今天买，之前买），dp[i] [1] 第i天不持有的现金（今天卖，之前卖）

2）dp [0] [0] = -prices[0], dp[0] [1] = 0

3）dp[i] [0] = max(dp [i-1] [0], -prices[i])  

​	 dp[i] [1] = max(dp[i-1] [1],**dp [i-1] [0]** + price[i] ) // 今天卖出代表着i-1天是持有的

4）遍历i一次[1,length)      返回最后状态dp[len-1] [1]

股票II

可以多次买卖一支股票，必须卖掉一个才能接着买

​     dp[i] [0] = max(dp [i-1] [0],**dp[i-1] [1]** -prices[i])  // 第i天买入代表i-1不持有

​	 dp[i] [1] = max(dp[i-1] [1],**dp [i-1] [0]** + price[i] ) // 今天卖出代表着i-1天是持有的

股票III

至多买卖2次股票

1）dp[i] [1] 和dp[i] [3] 代表第1次持有，第二次持有，初始化dp [0] [1] ,dp [0] [3] = -price[0]

​		dp[i] [2] 和dp[i] [4]代表第1次不持有，第2次不持有，初始化dp [0] [2] ,dp [0] [4] =0

2）dp[i] [1] = max(dp[i-1] [1], - prices[i])

​		dp[i] [2] = max(dp[i-1] [2], dp[i-1] [1] + prices[i])

​		dp[i] [3] = max(dp[i-1] [3], dp[i-1] [2] - prices[i])

​		dp[i] [4] = max(dp[i-1] [4], dp[i-1] [3] + prices[i])

股票IV

至多买卖k次股票

根据III中的状态将其泛化

dp[i] [j] [0] 第i天进行第j次买卖的持有状态	dp[i] [j] [1] 第i天进行第j次买卖的不持有状态

1）初始化 dp[0] [k] [0] 全部= -prices[0]  dp[0] [j] [1] 全部=0

2）dp[i] [j] [0] = max(dp[i-1] [j] [0], **dp[i-1] [j-1] [1]**- prices[i])  // 在i-1天处于不持有，不持有指的是j-1次不持有

​	  dp[i] [j] [1] = max(dp[i-1] [j] [1], **dp[i-1] [j] [0]** + prices[i])    // 在i-1天处于持有，想要卖第j次，就需要有第j次持有

| 问题   | 定义与循环                                                   | 初始化                                        | 递推式                                                       | 返回值   |
| ------ | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------------------------ | -------- |
| I      | 二维dp[len] [2]，0表示持有，1表示不持有；返回最后状态dp[len-1] [1]；i[1, len) | dp[0] [0] = -prices[0],dp[0] [1] = 0          | dp[i] [0] = max(dp [i-1] [0], -prices[i])  <br />dp[i] [1] = max(dp[i-1] [1],**dp [i-1] [0]** + price[i] ) | 最后的dp |
| II     | 与I相比仅仅dp[i] [0]递归式子不同                             |                                               | dp[i] [0] = max(dp [i-1] [0],**dp[i-1] [1]** -prices[i])  <br />dp[i] [1] = max(dp[i-1] [1],**dp [i-1] [0]** + price[i] ) | 最后的dp |
| III    | 直接用IV k=2                                                 |                                               |                                                              |          |
| IV     | **dp[len] [k+1] [2]** 0持有，1不持有 i [1,len)  j **[1, k]** | dp[0] [k] [0] = -prices[0], dp[0] [k] [1] = 0 | dp[i] [j] [0] = max(dp[i-1] [j] [0], **dp[i-1] [j-1] [1]**- prices[i])<br />dp[i] [j] [1] = max(dp[i-1] [j] [1], **dp[i-1] [j] [0]** + prices[i]) | 最后的dp |
| 冷冻期 | 冷冻1天，所以当天买的时候要在i-2的不持有状态上转移           | 需要初始化0天的和1天的共4个                   | dp[i] [0] = max(dp[i-1] [0], dp**[i-2]** [1] - prices[i]); <br />dp[i] [1] =max(dp[i-1] [1], dp[i-1] [0] + prices[i]); | 最后的dp |
| 手续费 | 卖的时候+price[i] - fee                                      | 初始化与II相同                                | dp[i] [0] = max(dp[i-1] [0], dp[i-1] [1] - prices[i]); <br />dp[i] [1] =max(dp[i-1] [1], dp[i-1] [0] + prices[i] - fee); |          |

## 子序列问题

每个状态值依赖前一个状态，用动规

初始化条件也是特殊情况的判断，需要先行返回



最长递增子序列

1）dp[i]：以nums[i]结尾的最长递增子序列

2）dp[k] = 1 k[0,len-1]

3）二重循环   i [1,len)	j [0,i)  **if (nums[i] > nums[j]) dp[i] =<font color='red'>max</font>(dp[i], dp[j] + 1)**

4）返回dp最大值，过程中取max



最长连续递增序列

1）dp[i]：以nums[i]结尾的最长连续递增子序列

2）dp[k] = 1 k[0,len-1]

3）一重循环  i [1,len)    **if (nums[i] > nums[i-1]) dp[i] =dp[i-1] + 1**

4）返回dp最大值，过程中取max



最长公共子串

1）dp[len1+1] [len2+1] dp[i] [j] :nums1[i-1]结尾，nums2[j-1]结尾的最长公共子串

2）dp[0] [0] =0

3）i [1,len1]  j[1,len2]   if (nums1[i-1] == nums2[j-1])  **dp[i] [j] = dp[i-1] [j-1] + 1**

4）返回最大值取dp的max



最长公共子序列

只有递推式变了  

if (nums1[i-1] == nums2[j-1])  **dp[i] [j] = dp[i-1] [j-1] + 1**

else dp[i] [j] =<font color='red'> **max**</font>(dp[i-1] [j], dp[i] [j-1])



最大子数组和

1）dp[len+1]

i [1,len]    dp[i] = Math.max(nums[i-1], dp[i-1] + nums[i-1]); // 和贪心的核心逻辑类似



判断子序列

看两个的最长公共子序列是否==s.length



不同的子序列

dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t，不同子序列的个数

s中有多少个t，相当于在s中删除一些元素让s==t的方法数

初始化0行全0（长度为0的s中有多少长度为k的t）0列全1

i [1,lenS]  j[1,lenT]

if (s[i] == t[j]) dp[i] [j] = dp[i-1] [j-1] + dp[i-1] [j] // 左上+上

else dp[i] [j] = dp[i-1] [j] // 判断s中有多少j，而非j中多少s，所以不用管dp[i] [j-1]

返回值：最后dp



两个字符串的删除和编辑

在s和t中都可以删除，让s==t，求最少需要删除的步数

求最大公共子序列，然后len1+len2-2*result

初始化0行递增k 0列递增k

返回最后dp

```java
if (charWord1[i-1] == charWord2[j-1]) {
	dp[i][j] = dp[i-1][j-1];//如果相等的话，不删除，抄下来前一状态
} else {
     dp[i][j] = Math.min(Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + 2);
      如果不相等，说明需要删除，有三种删除方法：
//    两个字符串的i-1,j-1都不取，都删除————dp[i-1][j-1] + 2
//    删除word1 i-1————dp[i-1][j] + 1
//    删除word2 j-1————dp[i][j-1] + 1
```

编辑操作（增删和替换均可）

唯一区别在于不相等的时候，

```
dp[i][j] = Math.min(Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + 1);
// 对s的增和对t的删除是相对的，区别在于替换，这里是+1，单纯删除时+2
```



判断回文子串个数

1）dp[i] [j] ：[i,j]区间上是否是回文串

2）只需要遍历矩阵的一半，j>=i

dp[i] [j] = dp[i+1] [j-1] 所以矩阵是下->上，左->右，，只遍历右上一半

```java
    public int countSubstrings(String s) {
            char[] charS = s.toCharArray();
            int res = 0;
            boolean[][] dp = new boolean[s.length()][s.length()];
//        因为需要知道dp[i+1][j-1]所以需要i倒序遍历，j正序遍历
            for (int i = s.length() - 1; i >=0 ; i--) {
                for (int j = i; j < s.length(); j++) {
                    // 首尾不等，一定不是回文
                    if (charS[i] != charS[j]) dp[i][j] = false;
                    else { // 首尾相等
                        if (j - i <= 1) { // 是aa，或者a的子串，说明是回文
                            dp[i][j] = true;
                            res ++;
                        } else { // 其他情况，dp[i][j]取决于dp[i+1][j-1]
                            dp[i][j] = dp[i+1][j-1];
                            if (dp[i][j]) res ++;
                        }
                    }
                }
            }
        return res;
    }
```



最长回文子序列

1）dp[i] [j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i] [j]。

2）初始化：求序列长度，dp[i] [i] = 1

3）i倒序，j正序

3）返回dp的最后 dp[0] [len-1]

```
public int longestPalindromeSubseq(String s) {
        char[] charS = s.toCharArray();
        int[][] dp = new int[s.length()][s.length()];
        for (int i = 0; i <s.length() ; i++) {
            dp[i][i] = 1;// 一个字符的最长回文串长度为1
        }
//        因为需要知道dp[i+1][j-1]所以需要i倒序遍历，j正序遍历
        for (int i = s.length() - 1; i >=0 ; i--) {
            for (int j = i + 1; j < s.length(); j++) {
                // 首尾相等,左右往里各走一步
                if (charS[i] == charS[j]) dp[i][j] = dp[i+1][j-1] + 2;
                else {
//                    首尾不等，选择左边+1或者右边-1
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                    }
                }
            }
//        最后的结果存储在最后到达的地方，即i=0,j=s.len-1
        return dp[0][s.length()-1];
    }
```

|      | 问题                       | 定义与循环                                            | 递推式                                                       | 返回值 |
| ---- | -------------------------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------ |
| 1    | 最长递增子序列             | dp[length]； 初值全1；i[1,len) j[0,i)                 | if (nums[i] > nums[j]) dp[i] =<font color='red'>max</font>(dp[i], dp[j] + 1) | 最大dp |
| 2    | 最长连续递增子序列         | dp[length]；初值全1；i[1,len)                         | **if (nums[i] > nums[i-1]) dp[i] =dp[i-1] + 1**              | 最大dp |
| 3    | 最长公共子串               | dp[len1+1] [len2+1] <br />i [1,len1]  j[1,len2]       | if (nums1[i-1] == nums2[j-1])  **dp[i] [j] = dp[i-1] [j-1] + 1** | 最大dp |
| 4    | 最长公共子序列             | dp[len1+1] [len2+1]<br />i [1,len1]  j[1,len2]        | if (nums1[i-1] == nums2[j-1])  dp[i] [j] = dp[i-1] [j-1] + 1<br />else dp[i] [j] =<font color='red'>max</font>(dp[i-1] [j], dp[i] [j-1]) | 最大dp |
| 5    | 不相交的线                 | 最长公共子序列                                        |                                                              |        |
| 6    | 最大子数组和               | dp[len+1] [1,len]                                     | dp[i] = Math.max(nums[i-1], dp[i-1] + nums[i-1]);            | 最大dp |
| 7    | 判断子序列                 | 最长公共子序列len==s.len                              |                                                              |        |
| 8    | 不同的子序列个数           | dp[len1+1] [len2+1]；0列全1                           | if(s[i-1] == t[j-1]) dp[i] [j] = dp[i-1] [j-1] + dp[i-1] [j]<br />else dp[i] [j] = dp[i-1] [j] | 最后dp |
| 9    | 两字符串删除编辑           | dp[len1+1] [len2+1]；0行0列初始为k                    | if (s[i-1] == t[j-1]) {	dp[i] [j] = dp[i-1] [j-1];}<br /> else {dp[i] [j] = Math.min(Math.min(dp[i-1] [j] + 1, dp[i] [j-1] + 1), dp[i-1] [j-1] + 2); // 删除，编辑是把最后一项换成+1 | 最后dp |
|      |                            |                                                       |                                                              |        |
| 10   | 回文子串数                 | 布尔型dp[len] [len]；i倒序j正序                       |                                                              |        |
| 11   | 切分为回文串的最小切分次数 | 根据上题的布尔dp，再次动规dp2[i]表示[0,i]最小切分次数 | for (int j = 0; j < i; j++) {     **if (dp[j+1] [i])** { <br />**dp2[i] = Math.min(dp2[i], dp2[j] + 1);**     } } |        |
| 12   | 最长回文子序列             | dp[i] [i] = 1；i倒序j正序                             |                                                              |        |

定义dp要不要+1：取决于递推式里面有没有dp[i-1]而i不应该从1开始的情况

取max：子序列里面要取max

初始化：对于判断递增的，涉及到个数的要小心

## 动规总结

确定dp数组与下标的含义，一般都是问题是什么，dp代表什么
递推式：多写几个，找规律
初始化：涉及到方法数，一般dp[0] = 1，要确定是二维/一维/三维，以及长度是n还是n+1
遍历顺序：根据递推式（dp[i] [j] = dp[i+1] [j-1] i正序j倒序）根据排列数还是组合数（背包）
打印dp数组

# 单调栈

通常是一维数组，要**寻找任一个元素的右边或者左边第一个比自己大或者小**的元素的位置，此时我们就要想到可以用单调栈了。

单调栈加入下标，存放我们遍历过的元素

求左右第一个比他大的元素，单调栈递增；循环在>栈顶的时候

求左右第一个比他小的元素，单调栈递减；

```
/**
 * [503] 下一个更大元素 II
 递增的单调栈
 * 给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。
 * */
public int[] nextGreaterElements(int[] nums) {
    int size = nums.length;
    int[] ans = new int[size];
    Arrays.fill(ans, -1);
    LinkedList<Integer> stack = new LinkedList<>();
    for (int i = 0; i < 2* size; i++) { // 放进去两次
        while (!stack.isEmpty() && nums[i % size] > nums[stack.peek()]) {
            ans[stack.peek()] = nums[i % size];
            stack.pop();// 为了保证单调栈
        }
        stack.push(i % size); // 放进去的是索引
    }

    return ans;
}




    /**
     * [84] 柱状图中最大的矩形
     * 每个柱子为高，其矩形宽度为：左边第一个比他小的元素下标，右边第一个比他小的元素下标
     * 但这个需要考虑边界，所以在height前后都插入最小高度0，让每个高度的柱子都被计算宽度
     递减的单调栈
     * */
    public int largestRectangleArea(int[] heights) {
        int[] newHeight = new int[heights.length + 2];
        for (int i = 0; i < heights.length; i ++) {
            newHeight[i+1] = heights[i];
        }
        LinkedList<Integer> stack = new LinkedList<>();
        int res = newHeight[0];
        for (int i = 0; i < newHeight.length; i++) {
            while (!stack.isEmpty() && newHeight[i] < newHeight[stack.peek()]) {
                int curIndex = stack.pop();
                if (!stack.isEmpty()) {
                    int leftIndex = stack.peek();
                    int curWidth = i - leftIndex -1;
                    res = Math.max(res, curWidth * newHeight[curIndex]);
                }
                res = Math.max(newHeight[curIndex], res);
            }
            stack.push(i);
        }
        return res;

    }
```

# 补充

## 双指针 滑动窗口

连续满足一定条件的**连续区间（子串子数组）的性质（长度等）**问题

快慢指针：一快一慢，步长一大一小。（是否有环，单链表找中间节点，删除倒数第n个节点，链表相交，
																	移除元素，替换空格，删除有序数组的重复项，）。

对撞指针：一左一右向中间逼近。（三数之和，有序数组的平方）

滑动窗口：类似计算机网络中的滑动窗口，一般是右端向右扩充，达到停止条件后右端不动，左端向右端逼近，逼近达到停止条件后，左端不动，右端继续扩充。只考虑窗口需要滑动的情况，先滑动了，再做不滑动的默认操作。
（长度最小的子数组正整数数组、无重复字符的最长子串、最大连续1的个数 允许有k个0、尽可能使字符串相等有maxCost转换、替换后的最长重复子串）

KMP算法：在一个字符串里面找子串（一定是子串子数组，不是子序列）

```java
* [283] 移动零
public void moveZeroes(int[] nums) {
    int slow = 0;
    for (int fast = 0; fast < nums.length; fast ++) {
        if (nums[fast] != 0) {
            nums[slow] = nums[fast];
            slow ++;
        }
    }
    for (int i = slow; i < nums.length; i ++) {
        nums[i] = 0;
    }
    System.out.println(Arrays.toString(nums));
}
```

轮转数组

```java
/**
 * 189. 旋转数组，原地旋转，整体翻转，前半部分翻转，后半部分翻转
 * */
public void rotate(int[] nums, int k) {
    k = k % nums.length;
    int n = nums.length;
    rotate1(nums, 0, n - 1);
    rotate1(nums, 0,k-1);
    rotate1(nums,k, n-1);
    System.out.println(Arrays.toString(nums));

}
void rotate1(int[] nums, int start, int end) {
    while (start <= end) {
        int temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start ++;
        end --;
    }
}
```

```java
/**
 * * [724] 寻找数组的中心下标
 * 求总和，求每个nums[i]包括其在内的左边，和包括其在内的右边是否相等，相等则返回i
 * */
public int pivotIndex(int[] nums) {
    int sum = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
    }
    int leftSum = 0;
    int rightSum = 0;
    for (int i = 0; i < nums.length; i++) {
        leftSum += nums[i];
        rightSum = sum - leftSum +nums[i];
        if (leftSum == rightSum) {
            return i;
        }
    }
    return -1;
}
```

## 前缀和

原理非常简单，但却很实用，当遇到「区间和」问题的时候肯定躲不过它。
计算方式是对数组进行了预处理，得到了从第 0 位置到第 i  位置的「和」。
可以快速求出数组 nums的指定区间 [ i , j ] 内所有元素的「和」。

前缀和+哈希优化：连续子数组问题：560. 和为 K 的子数组个数；1248. 统计「优美子数组」个数；643. 子数组最大平均数 I

```java
        this.result = new int[nums.length + 1];
        for (int k = 1; k < result.length; k++) {
            result[k] = result[k-1] + nums[k-1];
            // result[k]是算上nums[k-1]，[0,k-1]
        }
int sumIToJ = result[j+1] -  result[i]; // [i,j]区间内的和

// 统计「优美子数组」个数
    public int numberOfSubarrays(int[] nums, int k) {
        // key前缀和（即当前奇数的个数），value是奇数为key的子数组有value个。
        HashMap<Integer,Integer> map = new HashMap<>();
        map.put(0,1);// 初始化，有0个奇数的子数组有1个
        int res = 0, sum = 0;
        for (int num: nums) {
            sum += num & 1; // 奇数+1，偶数+0，前缀和不断累加
             if (map.containsKey(sum - k))
                    res += map.get(sum - k);
            map.put(sum, map.getOrDefault(sum,0) + 1);
        }
        return res;
    }
```

## 滑动窗口

滑动窗口思想：
①）窗口由两个指针构成，一个左指针left，一个右指针right，然后[left,right]表示的索引范围是一个窗口了。

②）右指针right的功能是用来扩展窗口：当窗口内的条件没有达到题目要求时，我们需要不断移动右指针right直到窗口内的条件第一次满足题目要求为止。

③）左指针left的功能是用来缩小窗口的：当窗口内的条件已满足题目条件或多于题目条件时（窗口溢出），我们缩小窗口，也就是左指针left需要右移直到窗口条件不满足为止。这时，我们需要记录当前窗口的大小，并更新目前为止满足条件的最小窗口记录。之后，再次扩展右指针right，使得窗口满足题目的条件。

注：滑动窗口用来处理连续满足一定条件的**连续区间（子串子数组）的性质（长度等）**问题的，两个指针都起始于原点，并一前一后向终点前进。比如：最小长度子数组，最大连续1的个数，最小覆盖子串。

整体思路：for fast外循环，满足条件while判断 slow内循环：结果回退，slow的移动。跳出while/if，记录结果。slow移动与否的判断，有时用到map（无重复字符的最长子串）

```java
    /**
     * 滑动窗口
     * 209. 长度最小的子数组
     * */
    public static int minSubArrayLen(int s, int[] nums){
        int resultLen = Integer.MAX_VALUE;
        int sum = 0;
        int slow = 0, fast = 0;
        for (fast = 0; fast < nums.length; fast ++) { // fast一重for循环
            sum += nums[fast];
            while (sum >= s) { //for循环判断是否满足条件，记录结果，原结果去掉left，left往右
                resultLen = Math.min(resultLen, fast - slow + 1);
                sum -= nums[slow ++];
            }
        }
        return resultLen == Integer.MAX_VALUE ? 0:resultLen;
    }

	/*
	* 1208. 尽可能使字符串相等:
	*/

    public int equalSubstring(String s, String t, int maxCost) {
        if (s.length() != t.length()) return 0;
        int result = 0;
        int curCost = 0;
        int slow = 0, fast;
        for (fast = 0; fast < s.length(); fast ++) {
            curCost += Math.abs(s.charAt(fast) - t.charAt(fast));
            while (curCost > maxCost) { // 滑动，先减去最开始的，再slow++
                int temp = Math.abs(s.charAt(slow) - t.charAt(slow));
                curCost -= temp;
                slow ++;
            }
            result = Math.max(result, fast - slow + 1);
        }
        return result;
    }


```



# 图论

BFS：带权重的，用Weight<vertex, value>作为边list的元素，用vertexMap<String,Integer>做点映射
1.点0~n-1，List<List<Weight>>edge下标表示点下标，List<Weight>存储内容，count表示点个数，visited[]表示点是否被访问，保证每个节点入队一次，出队一次；LinkedList<Integer> queue队列，入队起始点（单独判断起始点是否满足条件）。
2.while(队不为空)：出队temp，if (visited[temp]) continue; visited[temp] = true;获取其连接点List<Integer>，做处理。
								遍历后续点的List：!visited[] && 满足条件，入队

BFS可以处理课程表拓扑问题、除法求值、是否可达问题、层序的最少经过边的问题（一种最短路径）

## 拓扑排序

有向无环图DAG

1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。
2. 从图中删除该顶点和所有以它为起点的有向边。
3. 重复 1 和 2 直到当前的 DAG 图为空或**当前图中不存在无前驱的顶点为止**。

## 最小生成树

Kruskal Prime最小生成树：必须满足三个条件：

1. 图是连通图；
2. 图中包含了N个结点
3. 图中边的数量等于N-1条。
4. 边的权重之和越小越好

|      | 最小生成树                                                   | 最短路径                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 区别 | 所有点被连通                                                 | 不一定所有点                                                 |
| 定义 | 保证整个拓扑图的所有路径之和最小，但不能保证任意两点之间是最短路径。 | 最短路径是从一点出发，到达目的地的路径最小                   |
| 使用 | 遇到求所有路径之和最小的问题用最小生成树&并查集解决          | 遇到求两点间最短路径问题的用最短路，即从一个城市到另一个城市最短的路径问题 |
| 算法 | kruskal+并查集，用到的是Edge结构图                           | dijkstra算法单源最短路径，二维矩阵                           |

## 欧拉回路 VS 哈密顿回路

欧拉回路：经过**图中每边一次且仅一次**，回到原出发点。无向连通图存在欧拉回路的充分必要条件：图中所有顶点均有偶数度。

哈密顿回路：访问除原出发点以外的**每个点一次且仅一次**，回到原出发点。没有充分必要条件。

## 总结

### DFS BFS

构建图：三个成员变量，节点总数，节点，边。
节点如果是String，需要映射，节点如果直接是[0,len-1]则不用映射
将节点值作为下标，构建边的List<List>>，
		如果边有权重，那么边需要是自定义的Weight类型，存放<下一个节点b，a->b的权重>
		如果是**无向图，一定要构造双向连接**，即edge.get(i).add(j);edge.get(j).add(i)；其他的具体分析，除法求值（双向权重不同）

需要注意是不是无向图，无向图BFS需要visited数组。

```java
// 1.BFS用队列，获取到开始和结束的int，去边里面BFS
HashMap<String, Integer> vertexMap = new HashMap<>(); // 节点映射
List<List<Integer>> edge = new ArrayList<>(); // 无权边
List<List<Weight>> edge = new ArrayList<>(); // 有权边
 if (!vertexMap.containsKey(s)) {
            vertexMap.put(s,count++);
            edge.add(new ArrayList<>());
        } // 添加节点的代码
edge.get(start).add(new Weight(end, value)); // 添加边的核心代码

// 1.BFS核心代码：外面定义visited数组，入队start
        while (!queue.isEmpty()) {
            int temp = queue.pollFirst(); // 1.出队
            if (visited[temp]) continue; // 2.避免重复判断
            visited[temp] = true;
            List<Weight> tempList = edge.get(temp); // 获取下一条边
            for (Weight weight : tempList) { // 3.遍历下一条边
                // 入度-1
                int toVer = weight.getVertex();
                double toVal = weight.getValue();
                if (!visited[weight.vertex]) { // 4.未访问过则入队
                    distance[toVer] = distance[temp] * toVal;
                    queue.addLast(toVer);
                }
                if (toVer == end) return distance[end];
            }
        }
// 2.DFS用递归，和BFS的图结构完全相同
    public void dfs(int i) {
        List<Integer> tempList = edges.get(i);
        for (Integer integer : tempList) {
            if (!visited[integer]) {
                visited[integer] = true;
                dfs(integer);
            }
        }
    }
```

### 并查集 && 最小生成树

只适合无向图，关注是否联通，并**不关注方向**。图结构：邻接矩阵，Edge对象，邻接表也可以。

group的值并不代表最终的团伙数（group[1] = 2，后来group[2] = 3,2与3一伙，但1与2也是一伙的，group[1]不需要改为3，find递归可以知道1与3一伙，但直接通过group的值是不行的）

```java
// 3.最小生成树Kruskal算法，用的是Edge对象构建图，当然如果有必要也要做节点映射。
List<Edge> edges = new ArrayList<>();
 edges.add(new Edge(i,j,value)); // 起点，终点，权值
// 对边排序，调用并查集的unionSet(i,j)

//4.单源最短路径dijstra算法，用的是邻接矩阵
// 开始节点start，distance[count]表示距离，prev[count]记录路径，visited[count]记录是否访问,
//visited[start]不预初始化为true
        for (int i = 0; i < count; i++) {
            int tempV = -1;
            // 未被选过visited[y] = false，&& 距离最短distance[y]最小的点作为tempV，是被选中的点，最开始就是start
            for (int j = 0; j < count; j++) {
                if (!visited[j] && (tempV == -1 || distance[j] < distance[tempV])) {
                    tempV = j;
                }
            }
            visited[tempV] = true;
            for (int j = 0; j < n; j++) {
                // 从0开始，更新与x相连的所有点的距离，如果更小，则替换，同时记录路径prev，表示节点j的前驱节点
                if (matrix[tempV][j] < Inf && distance[tempV] + matrix[tempV][j] < distance[j]) {
                    distance[j] = distance[tempV] + matrix[tempV][j];
                    prev[j] = tempV;
                }
            }
        }
```

