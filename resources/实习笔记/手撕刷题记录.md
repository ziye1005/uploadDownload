# 双指针法 滑动窗口

连续满足一定条件的**连续区间（子串子数组）的性质（长度等）**问题

快慢指针：一快一慢，步长一大一小。（是否有环，单链表找中间节点，删除倒数第n个节点，链表相交，
																	移除元素，替换空格，删除有序数组的重复项，）。

对撞指针：一左一右向中间逼近。（三数之和，有序数组的平方）

滑动窗口：类似计算机网络中的滑动窗口，一般是右端向右扩充，达到停止条件后右端不动，左端向右端逼近，逼近达到停止条件后，左端不动，右端继续扩充。只考虑窗口需要滑动的情况，先滑动了，再做不滑动的默认操作。
（长度最小的子数组正整数数组、无重复字符的最长子串、最大连续1的个数 允许有k个0、尽可能使字符串相等有maxCost转换、替换后的最长重复子串）

KMP算法：在一个字符串里面找子串（一定是子串子数组，不是子序列）

# 前缀和

「区间和」问题

前缀和+哈希优化：连续子数组问题：560. 和为 K 的子数组个数；1248. 统计「优美子数组」个数；643. 子数组最大平均数 I

```java
        this.result = new int[nums.length + 1];
        for (int k = 1; k < result.length; k++) {
            result[k] = result[k-1] + nums[k-1];
            // result[k]是算上nums[k-1]，[0,k-1]
        }
int sumIToJ = result[j+1] -  result[i]; // [i,j]区间内的和

// 统计「优美子数组」个数
    public int numberOfSubarrays(int[] nums, int k) {
        // key前缀和（即当前奇数的个数），value是奇数为key的子数组有value个。
        HashMap<Integer,Integer> map = new HashMap<>();
        map.put(0,1);// 初始化，有0个奇数的子数组有1个
        int res = 0, sum = 0;
        for (int num: nums) {
            sum += num & 1; // 奇数+1，偶数+0，前缀和不断累加
             if (map.containsKey(sum - k))
                    res += map.get(sum - k);
            map.put(sum, map.getOrDefault(sum,0) + 1);
        }
        return res;
    }
```



# 单调栈

通常是一维数组，寻找左右第一个比他大的元素位置（单调递增栈，放进去的都是比他小的，>栈顶时循环出栈）。

单调栈加入下标，存放我们遍历过的元素下标。

```java
    public int trap(int[] height) {
        LinkedList<Integer> stack = new LinkedList<>();
        int res = 0;
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int lowIndex= stack.pop();// 凹槽出栈
                if (!stack.isEmpty()) { // 说明没有左侧了，就不用算了
                    int leftIndex = stack.peek(); //获取左侧，但是不是出栈
                    int curHeight = Math.min(height[leftIndex], height[i]) - height[lowIndex];
                    // curHeight是两个高度取小，但底下也许有高度，这个高度就是height[lowIndex]
                    int curWidth = i - leftIndex - 1; // 这是两个柱子中间
                    res += curHeight * curWidth;
                }
            }
            stack.push(i);
        }
        return res;
    }
```



# 动规



# 图论——BFS DFS 拓扑 并查集



# 十大排序

